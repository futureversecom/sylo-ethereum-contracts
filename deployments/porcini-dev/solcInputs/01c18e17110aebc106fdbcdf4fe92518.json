{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./OwnableUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\n    function __Ownable2Step_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\n    }\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\n     * 0 before setting it to a non-zero value.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "abdk-libraries-solidity/ABDKMath64x64.sol": {
      "content": "// SPDX-License-Identifier: BSD-4-Clause\n/*\n * ABDK Math 64.64 Smart Contract Library.  Copyright  2019 by ABDK Consulting.\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n */\npragma solidity ^0.8.0;\n\n/**\n * Smart contract library of mathematical functions operating with signed\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\n * basically a simple fraction whose numerator is signed 128-bit integer and\n * denominator is 2^64.  As long as denominator is always the same, there is no\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\n * represented by int128 type holding only the numerator.\n */\nlibrary ABDKMath64x64 {\n  /*\n   * Minimum value signed 64.64-bit fixed point number may have. \n   */\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\n\n  /*\n   * Maximum value signed 64.64-bit fixed point number may have. \n   */\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n  /**\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromInt (int256 x) internal pure returns (int128) {\n    unchecked {\n      require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\n      return int128 (x << 64);\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\n   * rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64-bit integer number\n   */\n  function toInt (int128 x) internal pure returns (int64) {\n    unchecked {\n      return int64 (x >> 64);\n    }\n  }\n\n  /**\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromUInt (uint256 x) internal pure returns (int128) {\n    unchecked {\n      require (x <= 0x7FFFFFFFFFFFFFFF);\n      return int128 (int256 (x << 64));\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\n   * number rounding down.  Revert on underflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return unsigned 64-bit integer number\n   */\n  function toUInt (int128 x) internal pure returns (uint64) {\n    unchecked {\n      require (x >= 0);\n      return uint64 (uint128 (x >> 64));\n    }\n  }\n\n  /**\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\n   * number rounding down.  Revert on overflow.\n   *\n   * @param x signed 128.128-bin fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function from128x128 (int256 x) internal pure returns (int128) {\n    unchecked {\n      int256 result = x >> 64;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\n   * number.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 128.128 fixed point number\n   */\n  function to128x128 (int128 x) internal pure returns (int256) {\n    unchecked {\n      return int256 (x) << 64;\n    }\n  }\n\n  /**\n   * Calculate x + y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function add (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) + y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x - y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sub (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) - y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x * y rounding down.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function mul (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) * y >> 64;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\n   * number and y is signed 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y signed 256-bit integer number\n   * @return signed 256-bit integer number\n   */\n  function muli (int128 x, int256 y) internal pure returns (int256) {\n    unchecked {\n      if (x == MIN_64x64) {\n        require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\n          y <= 0x1000000000000000000000000000000000000000000000000);\n        return -y << 63;\n      } else {\n        bool negativeResult = false;\n        if (x < 0) {\n          x = -x;\n          negativeResult = true;\n        }\n        if (y < 0) {\n          y = -y; // We rely on overflow behavior here\n          negativeResult = !negativeResult;\n        }\n        uint256 absoluteResult = mulu (x, uint256 (y));\n        if (negativeResult) {\n          require (absoluteResult <=\n            0x8000000000000000000000000000000000000000000000000000000000000000);\n          return -int256 (absoluteResult); // We rely on overflow behavior here\n        } else {\n          require (absoluteResult <=\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n          return int256 (absoluteResult);\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 256-bit integer number\n   */\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\n    unchecked {\n      if (y == 0) return 0;\n\n      require (x >= 0);\n\n      uint256 lo = (uint256 (int256 (x)) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\n      uint256 hi = uint256 (int256 (x)) * (y >> 128);\n\n      require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n      hi <<= 64;\n\n      require (hi <=\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\n      return hi + lo;\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function div (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n      int256 result = (int256 (x) << 64) / y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x signed 256-bit integer number\n   * @param y signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divi (int256 x, int256 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n\n      bool negativeResult = false;\n      if (x < 0) {\n        x = -x; // We rely on overflow behavior here\n        negativeResult = true;\n      }\n      if (y < 0) {\n        y = -y; // We rely on overflow behavior here\n        negativeResult = !negativeResult;\n      }\n      uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\n      if (negativeResult) {\n        require (absoluteResult <= 0x80000000000000000000000000000000);\n        return -int128 (absoluteResult); // We rely on overflow behavior here\n      } else {\n        require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        return int128 (absoluteResult); // We rely on overflow behavior here\n      }\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n      uint128 result = divuu (x, y);\n      require (result <= uint128 (MAX_64x64));\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate -x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function neg (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != MIN_64x64);\n      return -x;\n    }\n  }\n\n  /**\n   * Calculate |x|.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function abs (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != MIN_64x64);\n      return x < 0 ? -x : x;\n    }\n  }\n\n  /**\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function inv (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != 0);\n      int256 result = int256 (0x100000000000000000000000000000000) / x;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function avg (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      return int128 ((int256 (x) + int256 (y)) >> 1);\n    }\n  }\n\n  /**\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\n   * Revert on overflow or in case x * y is negative.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 m = int256 (x) * int256 (y);\n      require (m >= 0);\n      require (m <\n          0x4000000000000000000000000000000000000000000000000000000000000000);\n      return int128 (sqrtu (uint256 (m)));\n    }\n  }\n\n  /**\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y uint256 value\n   * @return signed 64.64-bit fixed point number\n   */\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\n    unchecked {\n      bool negative = x < 0 && y & 1 == 1;\n\n      uint256 absX = uint128 (x < 0 ? -x : x);\n      uint256 absResult;\n      absResult = 0x100000000000000000000000000000000;\n\n      if (absX <= 0x10000000000000000) {\n        absX <<= 63;\n        while (y != 0) {\n          if (y & 0x1 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x2 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x4 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x8 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          y >>= 4;\n        }\n\n        absResult >>= 64;\n      } else {\n        uint256 absXShift = 63;\n        if (absX < 0x1000000000000000000000000) { absX <<= 32; absXShift -= 32; }\n        if (absX < 0x10000000000000000000000000000) { absX <<= 16; absXShift -= 16; }\n        if (absX < 0x1000000000000000000000000000000) { absX <<= 8; absXShift -= 8; }\n        if (absX < 0x10000000000000000000000000000000) { absX <<= 4; absXShift -= 4; }\n        if (absX < 0x40000000000000000000000000000000) { absX <<= 2; absXShift -= 2; }\n        if (absX < 0x80000000000000000000000000000000) { absX <<= 1; absXShift -= 1; }\n\n        uint256 resultShift = 0;\n        while (y != 0) {\n          require (absXShift < 64);\n\n          if (y & 0x1 != 0) {\n            absResult = absResult * absX >> 127;\n            resultShift += absXShift;\n            if (absResult > 0x100000000000000000000000000000000) {\n              absResult >>= 1;\n              resultShift += 1;\n            }\n          }\n          absX = absX * absX >> 127;\n          absXShift <<= 1;\n          if (absX >= 0x100000000000000000000000000000000) {\n              absX >>= 1;\n              absXShift += 1;\n          }\n\n          y >>= 1;\n        }\n\n        require (resultShift < 64);\n        absResult >>= 64 - resultShift;\n      }\n      int256 result = negative ? -int256 (absResult) : int256 (absResult);\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sqrt (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x >= 0);\n      return int128 (sqrtu (uint256 (int256 (x)) << 64));\n    }\n  }\n\n  /**\n   * Calculate binary logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function log_2 (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x > 0);\n\n      int256 msb = 0;\n      int256 xc = x;\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n      int256 result = msb - 64 << 64;\n      uint256 ux = uint256 (int256 (x)) << uint256 (127 - msb);\n      for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\n        ux *= ux;\n        uint256 b = ux >> 255;\n        ux >>= 127 + b;\n        result += bit * int256 (b);\n      }\n\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate natural logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function ln (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x > 0);\n\n      return int128 (int256 (\n          uint256 (int256 (log_2 (x))) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128));\n    }\n  }\n\n  /**\n   * Calculate binary exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp_2 (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x < 0x400000000000000000); // Overflow\n\n      if (x < -0x400000000000000000) return 0; // Underflow\n\n      uint256 result = 0x80000000000000000000000000000000;\n\n      if (x & 0x8000000000000000 > 0)\n        result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\n      if (x & 0x4000000000000000 > 0)\n        result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\n      if (x & 0x2000000000000000 > 0)\n        result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\n      if (x & 0x1000000000000000 > 0)\n        result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\n      if (x & 0x800000000000000 > 0)\n        result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\n      if (x & 0x400000000000000 > 0)\n        result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\n      if (x & 0x200000000000000 > 0)\n        result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\n      if (x & 0x100000000000000 > 0)\n        result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\n      if (x & 0x80000000000000 > 0)\n        result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\n      if (x & 0x40000000000000 > 0)\n        result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\n      if (x & 0x20000000000000 > 0)\n        result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\n      if (x & 0x10000000000000 > 0)\n        result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\n      if (x & 0x8000000000000 > 0)\n        result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\n      if (x & 0x4000000000000 > 0)\n        result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\n      if (x & 0x2000000000000 > 0)\n        result = result * 0x1000162E525EE054754457D5995292026 >> 128;\n      if (x & 0x1000000000000 > 0)\n        result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\n      if (x & 0x800000000000 > 0)\n        result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\n      if (x & 0x400000000000 > 0)\n        result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\n      if (x & 0x200000000000 > 0)\n        result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\n      if (x & 0x100000000000 > 0)\n        result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\n      if (x & 0x80000000000 > 0)\n        result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\n      if (x & 0x40000000000 > 0)\n        result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\n      if (x & 0x20000000000 > 0)\n        result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\n      if (x & 0x10000000000 > 0)\n        result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\n      if (x & 0x8000000000 > 0)\n        result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\n      if (x & 0x4000000000 > 0)\n        result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\n      if (x & 0x2000000000 > 0)\n        result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\n      if (x & 0x1000000000 > 0)\n        result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\n      if (x & 0x800000000 > 0)\n        result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\n      if (x & 0x400000000 > 0)\n        result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\n      if (x & 0x200000000 > 0)\n        result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\n      if (x & 0x100000000 > 0)\n        result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\n      if (x & 0x80000000 > 0)\n        result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\n      if (x & 0x40000000 > 0)\n        result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\n      if (x & 0x20000000 > 0)\n        result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\n      if (x & 0x10000000 > 0)\n        result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\n      if (x & 0x8000000 > 0)\n        result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\n      if (x & 0x4000000 > 0)\n        result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\n      if (x & 0x2000000 > 0)\n        result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\n      if (x & 0x1000000 > 0)\n        result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\n      if (x & 0x800000 > 0)\n        result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\n      if (x & 0x400000 > 0)\n        result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\n      if (x & 0x200000 > 0)\n        result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\n      if (x & 0x100000 > 0)\n        result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\n      if (x & 0x80000 > 0)\n        result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\n      if (x & 0x40000 > 0)\n        result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\n      if (x & 0x20000 > 0)\n        result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\n      if (x & 0x10000 > 0)\n        result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\n      if (x & 0x8000 > 0)\n        result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\n      if (x & 0x4000 > 0)\n        result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\n      if (x & 0x2000 > 0)\n        result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\n      if (x & 0x1000 > 0)\n        result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\n      if (x & 0x800 > 0)\n        result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\n      if (x & 0x400 > 0)\n        result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\n      if (x & 0x200 > 0)\n        result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\n      if (x & 0x100 > 0)\n        result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\n      if (x & 0x80 > 0)\n        result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\n      if (x & 0x40 > 0)\n        result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\n      if (x & 0x20 > 0)\n        result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\n      if (x & 0x10 > 0)\n        result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\n      if (x & 0x8 > 0)\n        result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\n      if (x & 0x4 > 0)\n        result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\n      if (x & 0x2 > 0)\n        result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\n      if (x & 0x1 > 0)\n        result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\n\n      result >>= uint256 (int256 (63 - (x >> 64)));\n      require (result <= uint256 (int256 (MAX_64x64)));\n\n      return int128 (int256 (result));\n    }\n  }\n\n  /**\n   * Calculate natural exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x < 0x400000000000000000); // Overflow\n\n      if (x < -0x400000000000000000) return 0; // Underflow\n\n      return exp_2 (\n          int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 64.64-bit fixed point number\n   */\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\n    unchecked {\n      require (y != 0);\n\n      uint256 result;\n\n      if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        result = (x << 64) / y;\n      else {\n        uint256 msb = 192;\n        uint256 xc = x >> 192;\n        if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n        if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n        if (xc >= 0x100) { xc >>= 8; msb += 8; }\n        if (xc >= 0x10) { xc >>= 4; msb += 4; }\n        if (xc >= 0x4) { xc >>= 2; msb += 2; }\n        if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n        result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\n        require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n        uint256 hi = result * (y >> 128);\n        uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n        uint256 xh = x >> 192;\n        uint256 xl = x << 64;\n\n        if (xl < lo) xh -= 1;\n        xl -= lo; // We rely on overflow behavior here\n        lo = hi << 128;\n        if (xl < lo) xh -= 1;\n        xl -= lo; // We rely on overflow behavior here\n\n        result += xh == hi >> 128 ? xl / y : 1;\n      }\n\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n      return uint128 (result);\n    }\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\n   * number.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return unsigned 128-bit integer number\n   */\n  function sqrtu (uint256 x) private pure returns (uint128) {\n    unchecked {\n      if (x == 0) return 0;\n      else {\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\n        if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\n        if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\n        if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\n        if (xx >= 0x100) { xx >>= 8; r <<= 4; }\n        if (xx >= 0x10) { xx >>= 4; r <<= 2; }\n        if (xx >= 0x4) { r <<= 1; }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return uint128 (r < r1 ? r : r1);\n      }\n    }\n  }\n}\n"
    },
    "contracts/AuthorizedAccounts.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport \"./interfaces/IAuthorizedAccounts.sol\";\n\n/**\n * @notice Manages authorized accounts with limited permissions on behalf of main account\n * these authorized accounts are allowed to perform some certain actions in the Sylo network\n * in order to reduce the works for main account\n */\ncontract AuthorizedAccounts is\n    IAuthorizedAccounts,\n    Initializable,\n    Ownable2StepUpgradeable,\n    ERC165\n{\n    /**\n     * @notice Tracks authorized accounts for every main account\n     */\n    mapping(address => AuthorizedAccount[]) public authorizedAccounts;\n\n    event PermissionsAdded(\n        address indexed main,\n        address indexed authorized,\n        Permission[] permissions\n    );\n\n    event PermissionsRemoved(\n        address indexed main,\n        address indexed authorized,\n        Permission[] permissions\n    );\n\n    error AuthorizedAccountCannotBeZeroAddress();\n    error MainAccountCannotBeZeroAddress();\n    error AtBlockNumberCannotBeZero();\n    error AccountAlreadyAuthorized();\n    error AccountDoesNotExist();\n\n    function initialize() external initializer {\n        Ownable2StepUpgradeable.__Ownable2Step_init();\n    }\n\n    /**\n     * @notice Returns true if the contract implements the interface defined by\n     * `interfaceId` from ERC165.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAuthorizedAccounts).interfaceId;\n    }\n\n    /**\n     * @notice Adds new authorized accounts with certain permissions.\n     * This will revert if the account has already existed.\n     * @param authorized The address that the main account wants to authorize\n     * @param permissions The list of permissions that the authorized account\n     * can perform within the Sylo network.\n     */\n    function authorizeAccount(address authorized, Permission[] calldata permissions) external {\n        if (authorized == address(0)) {\n            revert AuthorizedAccountCannotBeZeroAddress();\n        }\n\n        // check if account has already been authorized\n        AuthorizedAccount[] storage authAccounts = authorizedAccounts[msg.sender];\n        for (uint i; i < authAccounts.length; ++i) {\n            if (authAccounts[i].account == authorized) {\n                if (authAccounts[i].authorizedAt != 0) {\n                    revert AccountAlreadyAuthorized();\n                }\n\n                authAccounts[i].authorizedAt = block.number;\n                return _addPermissions(authorized, authAccounts[i], permissions);\n            }\n        }\n\n        // add new authorized account to the list\n        authAccounts.push();\n        AuthorizedAccount storage newAccount = authAccounts[authAccounts.length - 1];\n        newAccount.account = authorized;\n        newAccount.authorizedAt = block.number;\n\n        _addPermissions(authorized, newAccount, permissions);\n    }\n\n    /**\n     * @notice Removes all permissions of a specific authorized account\n     * associated with the msg.sender, and sets the account's authorizedAt to 0.\n     * Note: It does not remove the authorized account from the list.\n     * This will revert if the account does not exist.\n     * @param authorized The address of the authorized account\n     */\n    function unauthorizeAccount(address authorized) external {\n        if (authorized == address(0)) {\n            revert AuthorizedAccountCannotBeZeroAddress();\n        }\n\n        AuthorizedAccount[] storage authAccounts = authorizedAccounts[msg.sender];\n        for (uint i; i < authAccounts.length; ++i) {\n            if (authAccounts[i].account == authorized) {\n                delete authAccounts[i].authorizedAt;\n                return _removePermissions(authorized, authAccounts[i], getAllPermissions());\n            }\n        }\n\n        revert AccountDoesNotExist();\n    }\n\n    /**\n     * @notice Adds new permissions to a specific authorized account.\n     * - Adding permissions that don't exist in the Permission enum will return\n     * with panic code 0x21 (convert a value that is too big or negative into an enum type).\n     * - Adding duplicate permissions will update the permissions' authorizedAt value.\n     * - Adding permissions that were previously unauthorized will update\n     * the authorizedAt and unauthorizedAt values (refer to the comment in\n     * IAuthorizedAccount -> AuthorizedPermission struct).\n     * This will revert if the account does not exist.\n     * @param authorized The authorized account address\n     * @param permissions The new permissions will be added to the authorized account\n     */\n    function addPermissions(address authorized, Permission[] calldata permissions) external {\n        if (authorized == address(0)) {\n            revert AuthorizedAccountCannotBeZeroAddress();\n        }\n\n        AuthorizedAccount[] storage authAccounts = authorizedAccounts[msg.sender];\n        for (uint i; i < authAccounts.length; ++i) {\n            if (authAccounts[i].account == authorized) {\n                return _addPermissions(authorized, authAccounts[i], permissions);\n            }\n        }\n\n        revert AccountDoesNotExist();\n    }\n\n    function _addPermissions(\n        address authorized,\n        AuthorizedAccount storage authAccount,\n        Permission[] memory permissions\n    ) private {\n        for (uint i; i < permissions.length; ++i) {\n            bool exists;\n            for (uint j; j < authAccount.permissions.length; ++j) {\n                AuthorizedPermission storage authPermission = authAccount.permissions[j];\n                if (permissions[i] == authPermission.permission) {\n                    exists = true;\n                    authPermission.authorizedAt = block.number;\n\n                    // make sure unauthorizedAt is not greater than authorizedAt\n                    // (refer to the comment in IAuthorizedAccount -> AuthorizedPermission struct)\n                    if (authPermission.unauthorizedAt > authPermission.authorizedAt) {\n                        authPermission.unauthorizedAt = authPermission.authorizedAt;\n                    }\n                    break;\n                }\n            }\n            if (!exists) {\n                authAccount.permissions.push(\n                    AuthorizedPermission({\n                        permission: permissions[i],\n                        authorizedAt: block.number,\n                        unauthorizedAt: 0\n                    })\n                );\n            }\n        }\n\n        emit PermissionsAdded(msg.sender, authorized, permissions);\n    }\n\n    /**\n     * @notice Removes permissions of specific authorized account.\n     * - Removing permissions that don't exist in the Permission enum will return\n     * with panic code 0x21 (convert a value that is too big or negative into an enum type).\n     * - Removing duplicate/authorized permissions will update the permissions'\n     * unauthorizedAt value.\n     * This will revert if the account does not exist.\n     * @param authorized The address of authorized account\n     * @param permissions The list of permissions will be removed\n     */\n    function removePermissions(address authorized, Permission[] calldata permissions) external {\n        if (authorized == address(0)) {\n            revert AuthorizedAccountCannotBeZeroAddress();\n        }\n\n        AuthorizedAccount[] storage authAccounts = authorizedAccounts[msg.sender];\n        for (uint i; i < authAccounts.length; ++i) {\n            if (authAccounts[i].account == authorized) {\n                return _removePermissions(authorized, authAccounts[i], permissions);\n            }\n        }\n\n        revert AccountDoesNotExist();\n    }\n\n    function _removePermissions(\n        address authorized,\n        AuthorizedAccount storage authAccount,\n        Permission[] memory permissions\n    ) private {\n        for (uint i; i < permissions.length; ++i) {\n            for (uint j; j < authAccount.permissions.length; ++j) {\n                if (permissions[i] == authAccount.permissions[j].permission) {\n                    // only update unauthorizedAt if the permission is authorized\n                    if (\n                        authAccount.permissions[j].authorizedAt >=\n                        authAccount.permissions[j].unauthorizedAt\n                    ) {\n                        authAccount.permissions[j].unauthorizedAt = block.number + 1;\n                    }\n                    break;\n                }\n            }\n        }\n\n        emit PermissionsRemoved(msg.sender, authorized, permissions);\n    }\n\n    /**\n     * @notice Validates permission of an authorized account associated with the main account.\n     *\n     * @param main The address of main account\n     * @param authorized The address of authorized account\n     * @param permission The permission needs to be verified with the authorized account\n     * @param atBlock The block number to check if the permission is valid between\n     * the permission's authorizedAt and unauthorizedAt period. It is added later to prevent\n     * the timing attack. E.g. If the main account authorizes the PersonalSign permission at\n     * block 1, creates a ticket at block 2, then unauthorizes the permission at block 3, the\n     * ticket will be invalid and cannot be redeemed. To avoid this, the `atBlock` param is\n     * needed to check if the permission is authorized between its authorizedAt and unauthorizedAt\n     * duration.\n     *\n     * @return boolean value\n     */\n    function validatePermission(\n        address main,\n        address authorized,\n        Permission permission,\n        uint256 atBlock\n    ) external view returns (bool) {\n        if (main == address(0)) {\n            revert MainAccountCannotBeZeroAddress();\n        }\n\n        if (authorized == address(0)) {\n            revert AuthorizedAccountCannotBeZeroAddress();\n        }\n\n        if (atBlock == 0) {\n            revert AtBlockNumberCannotBeZero();\n        }\n\n        AuthorizedAccount[] storage authAccounts = authorizedAccounts[main];\n\n        for (uint i = 0; i < authAccounts.length; ++i) {\n            if (authAccounts[i].account == authorized) {\n                for (uint j = 0; j < authAccounts[i].permissions.length; ++j) {\n                    if (authAccounts[i].permissions[j].permission == permission) {\n                        uint256 authorizedAt = authAccounts[i].permissions[j].authorizedAt;\n                        uint256 unauthorizedAt = authAccounts[i].permissions[j].unauthorizedAt;\n\n                        bool isPermissionUnauthorized = authorizedAt > 0 &&\n                            authorizedAt < unauthorizedAt;\n                        if (isPermissionUnauthorized) {\n                            // the permission was previously valid, so we check that\n                            // the `atBlock` is referencing a time when the permission was valid\n                            return authorizedAt <= atBlock && atBlock < unauthorizedAt;\n                        }\n\n                        // otherwise just check if the permission was authorized before the\n                        // atBlock\n                        return authorizedAt > 0 && authorizedAt <= atBlock;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @notice Get all authorized accounts associated with a given account\n     * @param main The address of main account\n     * @return An array of authorized accounts\n     */\n    function getAuthorizedAccounts(\n        address main\n    ) external view returns (AuthorizedAccount[] memory) {\n        if (main == address(0)) {\n            revert MainAccountCannotBeZeroAddress();\n        }\n\n        return authorizedAccounts[main];\n    }\n\n    function getAllPermissions() internal pure returns (Permission[] memory) {\n        Permission[] memory permissions = new Permission[](1);\n        permissions[0] = Permission.PersonalSign;\n        return permissions;\n    }\n}\n"
    },
    "contracts/epochs/EpochsManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../Registries.sol\";\nimport \"../staking/Directory.sol\";\nimport \"../interfaces/epochs/IEpochsManager.sol\";\nimport \"../payments/ticketing/TicketingParameters.sol\";\n\ncontract EpochsManager is IEpochsManager, Initializable, Ownable2StepUpgradeable, ERC165 {\n    Directory public _directory;\n\n    Registries public _registries;\n\n    IERC721 public _rootSeekers;\n\n    TicketingParameters public _ticketingParameters;\n\n    /**\n     * @notice Track seekers that have joined for a specific epoch.\n     */\n    mapping(uint256 => mapping(uint256 => address)) public activeSeekers;\n\n    // Define all Epoch specific parameters here.\n    // When initializing an epoch, these parameters are read,\n    // along with parameters from the other contracts to create the\n    // new epoch.\n\n    /**\n     * @notice A mapping of all epochs that have been initialized.\n     */\n    mapping(uint256 => Epoch) public epochs;\n\n    /**\n     * @notice The block number since the first epoch can be initialized.\n     */\n    uint256 public initialEpoch;\n\n    /**\n     * @notice The duration in blocks an epoch will last for.\n     */\n    uint256 public epochDuration;\n\n    /**\n     * @notice The value of the integer used as the current\n     * epoch's identifier. This value is incremented as each epoch\n     * is initialized.\n     */\n    uint256 public currentIteration;\n\n    event NewEpoch(uint256 indexed epochId);\n    event EpochJoined(uint256 indexed epochId, address indexed node, uint256 indexed seekerId);\n    event InitialEpochUpdated(uint256 initialEpoch);\n    event EpochDurationUpdated(uint256 epochDuration);\n\n    error SeekerOwnerMismatch();\n    error InitialEpochCannotBeZero();\n    error EpochDurationCannotBeZero();\n    error DirectoryCannotBeZeroAddress();\n    error RegistriesCannotBeZeroAddress();\n    error RootSeekerCannotBeZeroAddress();\n    error EpochHasNotEnded(uint256 epochId);\n    error SeekerAccountCannotBeZeroAddress();\n    error TicketingParametersCannotBeZeroAddress();\n    error SeekerAlreadyJoinedEpoch(uint256 epochId, uint256 seekerId);\n    error InitialEpochNotYetReady(uint256 expectedBlock, uint256 currentBlock);\n\n    function initialize(\n        IERC721 rootSeekers,\n        Directory directory,\n        Registries registries,\n        TicketingParameters ticketingParameters,\n        uint256 _initialEpoch,\n        uint256 _epochDuration\n    ) external initializer {\n        if (address(rootSeekers) == address(0)) {\n            revert RootSeekerCannotBeZeroAddress();\n        }\n\n        SyloUtils.validateContractInterface(\n            \"Directory\",\n            address(directory),\n            type(IDirectory).interfaceId\n        );\n\n        SyloUtils.validateContractInterface(\n            \"Registries\",\n            address(registries),\n            type(IRegistries).interfaceId\n        );\n\n        SyloUtils.validateContractInterface(\n            \"TicketingParameters\",\n            address(ticketingParameters),\n            type(ITicketingParameters).interfaceId\n        );\n\n        Ownable2StepUpgradeable.__Ownable2Step_init();\n\n        _rootSeekers = rootSeekers;\n        _directory = directory;\n        _registries = registries;\n        _ticketingParameters = ticketingParameters;\n\n        initialEpoch = _initialEpoch;\n        epochDuration = _epochDuration;\n    }\n\n    /**\n     * @notice Returns true if the contract implements the interface defined by\n     * `interfaceId` from ERC165.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IEpochsManager).interfaceId;\n    }\n\n    /**\n     * @notice Call this to initialize the next epoch. On success, a `NewEpoch` event\n     * will be emitted.\n     * @dev The function will read the current set of network parameters, and store\n     * the parameters in a new Epoch struct. The end block of the current epoch\n     * will also be set to a non-zero value.\n     */\n    function initializeEpoch() external returns (uint256) {\n        if (currentIteration == 0 && initialEpoch > block.number) {\n            revert InitialEpochNotYetReady(initialEpoch, block.number);\n        }\n\n        Epoch storage current = epochs[currentIteration];\n\n        uint256 end = current.startBlock + current.duration;\n        if (end > block.number) {\n            revert EpochHasNotEnded(currentIteration);\n        }\n\n        (\n            uint256 faceValue,\n            uint128 baseLiveWinProb,\n            uint128 expiredWinProb,\n            uint256 ticketDuration,\n            uint32 decayRate\n        ) = _ticketingParameters.getTicketingParameters();\n\n        uint256 nextEpochId = getNextEpochId();\n\n        epochs[nextEpochId] = Epoch(\n            block.number,\n            epochDuration,\n            0,\n            _registries.defaultPayoutPercentage(),\n            decayRate,\n            faceValue,\n            baseLiveWinProb,\n            expiredWinProb,\n            ticketDuration\n        );\n\n        current.endBlock = block.number;\n\n        currentIteration = nextEpochId;\n\n        _directory.setCurrentDirectory(nextEpochId);\n\n        emit NewEpoch(nextEpochId);\n\n        return nextEpochId;\n    }\n\n    /**\n     * @notice Set the first epoch starting block. Only callable by the owner.\n     * @param _initialEpoch The block number when the first epoch can be initialized.\n     */\n    function setInitialEpoch(uint256 _initialEpoch) external onlyOwner {\n        if (_initialEpoch == 0) {\n            revert InitialEpochCannotBeZero();\n        }\n        initialEpoch = _initialEpoch;\n        emit InitialEpochUpdated(_initialEpoch);\n    }\n\n    /**\n     * @notice Set the epoch duration. Will take effect in the next epoch. Only\n     * callable by the owner.\n     * @param _epochDuration The epoch duration in number of blocks.\n     */\n    function setEpochDuration(uint256 _epochDuration) external onlyOwner {\n        if (_epochDuration == 0) {\n            revert EpochDurationCannotBeZero();\n        }\n        epochDuration = _epochDuration;\n        emit EpochDurationUpdated(epochDuration);\n    }\n\n    /**\n     * @notice Retrieve the parameters for the current epoch.\n     * @return The current Epoch parameters.\n     */\n    function getCurrentActiveEpoch() external view returns (uint256, Epoch memory) {\n        return (currentIteration, epochs[currentIteration]);\n    }\n\n    /**\n     * @notice Nodes should call this to join the next epoch. It will\n     * initialize the next reward pool and set the stake for the next directory.\n     * @dev This is a proxy function for `initalizeNextRewardPool` and\n     * `joinNextDirectory`.\n     */\n    function joinNextEpoch() external {\n        Registries.Registry memory registry = _registries.getRegistry(msg.sender);\n\n        // validate the node's seeker ownership\n        if (registry.seekerAccount == address(0)) {\n            revert SeekerAccountCannotBeZeroAddress();\n        }\n\n        uint256 seekerId = registry.seekerId;\n\n        address owner = _rootSeekers.ownerOf(seekerId);\n        if (registry.seekerAccount != owner) {\n            revert SeekerOwnerMismatch();\n        }\n\n        uint256 nextEpoch = getNextEpochId();\n        if (activeSeekers[nextEpoch][seekerId] != address(0)) {\n            revert SeekerAlreadyJoinedEpoch(nextEpoch, seekerId);\n        }\n\n        activeSeekers[nextEpoch][seekerId] = msg.sender;\n\n        _directory._rewardsManager().initializeNextRewardPool(msg.sender);\n        _directory.joinNextDirectory(msg.sender, seekerId);\n\n        emit EpochJoined(nextEpoch, msg.sender, seekerId);\n    }\n\n    /**\n     * @notice Retrieve the epoch parameter for the given id.\n     * @param epochId The id of the epoch to retrieve.\n     * @return The epoch parameters associated with the id.\n     */\n    function getEpoch(uint256 epochId) external view returns (Epoch memory) {\n        return epochs[epochId];\n    }\n\n    /**\n     * @notice Retrieve the integer value that will be used for the\n     * next epoch id.\n     * @return The next epoch id identifier.\n     */\n    function getNextEpochId() public view returns (uint256) {\n        return currentIteration + 1;\n    }\n}\n"
    },
    "contracts/interfaces/epochs/IEpochsManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\ninterface IEpochsManager {\n    /**\n     * @dev This struct will hold all network parameters that will be static\n     * for the entire epoch. This value will be stored in a mapping, where the\n     * key is the current epoch id.\n     */\n    struct Epoch {\n        // time related variables\n        uint256 startBlock; // Block the epoch was initialized\n        uint256 duration; // Minimum time epoch will be alive measured in number of blocks\n        uint256 endBlock; // Block the epoch ended (and when the next epoch was initialized)\n        // Zero here represents the epoch has not yet ended.\n\n        // registry variables\n        uint32 defaultPayoutPercentage;\n        // ticketing variables\n        uint32 decayRate;\n        uint256 faceValue;\n        uint128 baseLiveWinProb;\n        uint128 expiredWinProb;\n        uint256 ticketDuration;\n    }\n\n    function initializeEpoch() external returns (uint256);\n\n    function setEpochDuration(uint256 _epochDuration) external;\n\n    function getCurrentActiveEpoch() external view returns (uint256, Epoch memory);\n\n    function joinNextEpoch() external;\n\n    function getEpoch(uint256 epochId) external view returns (Epoch memory);\n\n    function getNextEpochId() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IAuthorizedAccounts.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\ninterface IAuthorizedAccounts {\n    enum Permission {\n        // PersonalSign permission allows the authorized account to\n        // sign on behalf of the sending account.\n        PersonalSign\n    }\n\n    /**\n     * @dev This type will hold the permission type and the block number from\n     * which the permission was set to be authorized and unauthorized.\n     * The permission is authorized when authorizedAt >= unauthorizedAt.\n     *\n     * Note: authorizedAt and unauthorizedAt won't be set to 0 when the permission\n     * is updated, because they are both needed when validating the permission.\n     */\n    struct AuthorizedPermission {\n        // Permission type\n        Permission permission;\n        // Block number from which the permission was set to be authorized.\n        // If the transaction is called in block 1, the permission is\n        // authorized from block 1 (authorizedAt = block.number).\n        uint256 authorizedAt;\n        // Block number from which the permission was set to be unauthorized.\n        // If the transaction is called in block 1, the permission is\n        // unauthorized from block 2 (unauthorizedAt = block.number + 1)\n        // unauthorizedAt is set that way to avoid the case where the\n        // permission is authorized and unauthorized in the same block:\n        // E.g. addPermission is called => authorizedAt = 1\n        //      removePermission is called => unauthorizedAt = 1\n        // => We cannot tell if the permission is authorized or not.\n        // E.g. addPermission is called => authorizedAt = 1\n        //      removePermission is called => unauthorizedAt = 2\n        //      addPermission is called => authorizedAt = 1 AND update unauthorizedAt = authorizedAt = 1\n        // => The permission is authorized when authorizedAt >= unauthorizedAt\n        uint256 unauthorizedAt;\n    }\n\n    struct AuthorizedAccount {\n        // The authorized account\n        address account;\n        // Block number at which the account was authorized.\n        // If the transaction is called in block 1, the account is\n        // authorized at block 1 (authorizedAt = block.number).\n        // If the account is unauthorized, authorizedAt will be set to 0.\n        uint256 authorizedAt;\n        // Permission list\n        AuthorizedPermission[] permissions;\n    }\n\n    function authorizeAccount(address authorized, Permission[] calldata permissions) external;\n\n    function unauthorizeAccount(address authorized) external;\n\n    function addPermissions(address authorized, Permission[] calldata permissions) external;\n\n    function removePermissions(\n        address authorized,\n        Permission[] calldata permissionsToRemove\n    ) external;\n\n    function validatePermission(\n        address main,\n        address authorized,\n        Permission permission,\n        uint256 atBlock\n    ) external returns (bool);\n\n    function getAuthorizedAccounts(\n        address main\n    ) external view returns (AuthorizedAccount[] memory);\n}\n"
    },
    "contracts/interfaces/IFuturePassRegistrar.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\ninterface IFuturePassRegistrar {\n    function futurepassOf(address owner) external view returns (address);\n\n    function create(address owner) external returns (address);\n}\n"
    },
    "contracts/interfaces/IRegistries.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\ninterface IRegistries {\n    struct Registry {\n        // Percentage of a tickets value that will be rewarded to\n        // delegated stakers expressed as a fraction of 100000.\n        // This value is currently locked to the default payout percentage\n        // until epochs are implemented.\n        uint32 payoutPercentage;\n        // Public http/s endpoint to retrieve additional metadata\n        // about the node.\n        // The current metadata schema is as follows:\n        //  { name: string, multiaddrs: string[] }\n        string publicEndpoint;\n        // The account which owns a seeker that will be used to\n        // operate the Node for this registry.\n        address seekerAccount;\n        // The id of the seeker used to operate the node. The owner\n        // of this id should be the seeker account.\n        uint256 seekerId;\n    }\n\n    function register(string calldata publicEndpoint) external;\n\n    function setDefaultPayoutPercentage(uint32 _defaultPayoutPercentage) external;\n\n    function setSeekerAccount(\n        address seekerAccount,\n        uint256 seekerId,\n        bytes32 nonce,\n        bytes calldata signature\n    ) external;\n\n    function revokeSeekerAccount(address node) external;\n\n    function getRegistry(address account) external view returns (Registry memory);\n\n    function getNodes() external view returns (address[] memory);\n\n    function getRegistries(\n        uint256 start,\n        uint256 end\n    ) external view returns (address[] memory, Registry[] memory);\n\n    function getTotalNodes() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ISeekerPowerOracle.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\ninterface ISeekerPowerOracle {\n    function setOracle(address oracle) external;\n\n    function registerSeekerPowerRestricted(uint256 seekerId, uint256 power) external;\n\n    function registerSeekerPower(\n        uint256 seekerId,\n        uint256 power,\n        bytes32 nonce,\n        bytes calldata proof\n    ) external;\n\n    function getSeekerPower(uint256 seekerId) external view returns (uint256);\n\n    function getProofMessage(\n        uint256 seekerId,\n        uint256 power,\n        bytes32 nonce\n    ) external pure returns (bytes memory);\n}\n"
    },
    "contracts/interfaces/payments/ISyloTicketing.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\ninterface ISyloTicketing {\n    struct Deposit {\n        uint256 escrow; // Balance of users escrow\n        uint256 penalty; // Balance of users penalty\n        uint256 unlockAt; // Block number a user can withdraw their balances\n    }\n\n    struct User {\n        address main; // Main address of the ticket sender or receiver\n        address delegated; // Delegated address used to sign and redeem tickets\n    }\n\n    struct Ticket {\n        uint256 epochId; // The epoch this ticket is associated with\n        User sender; // Ticket sender's main and delegated addresses\n        User receiver; // Ticket receiver's main and delegated addresses\n        address redeemer; // Address of the intended recipient\n        uint256 generationBlock; // Block number the ticket was generated\n        bytes32 redeemerCommit; // Hash of the secret random number of the redeemer\n    }\n\n    // A type of ticket that does not explicit state the receiver address.\n    struct MultiReceiverTicket {\n        uint256 epochId; // The epoch this ticket is associated with\n        User sender; // Ticket sender's main and delegated addresses\n        address redeemer; // Address of the intended recipient\n        uint256 generationBlock; // Block number the ticket was generated\n        bytes32 redeemerCommit; // Hash of the secret random number of the redeemer\n    }\n\n    function setUnlockDuration(uint256 _unlockDuration) external;\n\n    function depositEscrow(uint256 amount, address account) external;\n\n    function depositPenalty(uint256 amount, address account) external;\n\n    function unlockDeposits() external returns (uint256);\n\n    function lockDeposits() external;\n\n    function withdraw() external;\n\n    function redeem(\n        Ticket calldata ticket,\n        uint256 redeemerRand,\n        bytes calldata senderSig,\n        bytes calldata receiverSig\n    ) external;\n\n    function redeemMultiReceiver(\n        MultiReceiverTicket calldata ticket,\n        uint256 redeemerRand,\n        User calldata receiver,\n        bytes calldata senderSig,\n        bytes calldata receiverSig\n    ) external;\n}\n"
    },
    "contracts/interfaces/payments/ticketing/IRewardsManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\ninterface IRewardsManager {\n    /**\n     * @dev This type will hold the necessary information for delegated stakers\n     * to make reward claims against their Node. Every Node will initialize\n     * and store a new Reward Pool for each epoch they participate in.\n     */\n    struct RewardPool {\n        // Tracks the balance of the reward pool owed to the stakers\n        uint256 stakersRewardTotal;\n        // Tracks the block number this reward pool was initialized\n        uint256 initializedAt;\n        // The total active stake for the node for will be the sum of the\n        // stakes owned by its delegators and the node's own stake.\n        uint256 totalActiveStake;\n        // track the cumulative reward factor as of the time the first ticket\n        // for this pool was redeemed\n        int128 initialCumulativeRewardFactor;\n    }\n\n    struct LastClaim {\n        // The epoch the claim was made.\n        uint256 claimedAt;\n        // The stake at the time the claim was made. This is tracked as\n        // rewards can only be claimed after an epoch has ended, but the\n        // user's stake may have changed by then. This field tracks the\n        // staking value before the change so the reward for that epoch\n        // can be manually calculated.\n        uint256 stake;\n    }\n\n    function getRewardPool(\n        uint256 epochId,\n        address stakee\n    ) external view returns (RewardPool memory);\n\n    function getRewardPoolKey(uint256 epochId, address stakee) external pure returns (bytes32);\n\n    function getRewardPoolStakersTotal(\n        uint256 epochId,\n        address stakee\n    ) external view returns (uint256);\n\n    function getRewardPoolActiveStake(\n        uint256 epochId,\n        address stakee\n    ) external view returns (uint256);\n\n    function getPendingRewards(address stakee) external view returns (uint256);\n\n    function getLastClaim(address stakee, address staker) external view returns (LastClaim memory);\n\n    function getTotalEpochRewards(uint256 epochId) external view returns (uint256);\n\n    function getTotalEpochStakingRewards(uint256 epochId) external view returns (uint256);\n\n    function initializeNextRewardPool(address stakee) external;\n\n    function incrementRewardPool(address stakee, uint256 amount) external;\n\n    function claimStakingRewards(address stakee) external returns (uint256);\n\n    function updatePendingRewards(address stakee, address staker) external;\n}\n"
    },
    "contracts/interfaces/payments/ticketing/ITicketingParameters.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\ninterface ITicketingParameters {\n    function setFaceValue(uint256 _faceValue) external;\n\n    function setBaseLiveWinProb(uint128 _baseLiveWinProb) external;\n\n    function setExpiredWinProb(uint128 _expiredWinProb) external;\n\n    function setDecayRate(uint32 _decayRate) external;\n\n    function setTicketDuration(uint256 _ticketDuration) external;\n\n    function getTicketingParameters()\n        external\n        view\n        returns (uint256, uint128, uint128, uint256, uint32);\n}\n"
    },
    "contracts/interfaces/staking/IDirectory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\ninterface IDirectory {\n    /**\n     * @dev A DirectoryEntry will be stored for every node that joins the\n     * network in a specific epoch. The entry will contain the stakee's\n     * address, and a boundary value which is a sum of the current directory's\n     * total stake, and the current stakee's total stake.\n     */\n    struct DirectoryEntry {\n        address stakee;\n        uint256 boundary;\n    }\n\n    /**\n     * @dev An EpochDirectory will be stored for every epoch. The\n     * directory will be constructed piece by piece as Nodes join,\n     * each adding their own directory entry based on their current\n     * stake value.\n     */\n    struct EpochDirectory {\n        DirectoryEntry[] entries;\n        mapping(address => uint256) stakes;\n        uint256 totalStake;\n    }\n\n    function setCurrentDirectory(uint256 epochId) external;\n\n    function joinNextDirectory(address stakee, uint256 seekerId) external;\n\n    function scan(uint128 point) external view returns (address stakee);\n\n    function scanWithEpochId(\n        uint128 point,\n        uint256 epochId\n    ) external view returns (address stakee);\n\n    function getTotalStakeForStakee(\n        uint256 epochId,\n        address stakee\n    ) external view returns (uint256);\n\n    function getTotalStake(uint256 epochId) external view returns (uint256);\n\n    function getEntries(\n        uint256 epochId\n    ) external view returns (address[] memory, uint256[] memory);\n}\n"
    },
    "contracts/interfaces/staking/IStakingManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\ninterface IStakingManager {\n    /**\n     * For every Node, there will be a mapping of the staker to a\n     * StakeEntry. The stake entry tracks the amount of stake in SOLO,\n     * and also when the stake was updated.\n     */\n    struct StakeEntry {\n        uint256 amount;\n        // Block number this entry was updated at\n        uint256 updatedAt;\n        // Epoch this entry was updated. The stake will become active\n        // in the following epoch\n        uint256 epochId;\n    }\n\n    /**\n     * Every Node must have stake in order to participate in the Epoch.\n     * Stake can be provided by the Node itself or by other accounts in\n     * the network.\n     */\n    struct Stake {\n        // Track each stake entry associated to a node\n        mapping(address => StakeEntry) stakeEntries;\n        // The total stake held by this contract for a node,\n        // which will be the sum of all addStake and unlockStake calls\n        uint256 totalManagedStake;\n    }\n\n    /**\n     * This struct will track stake that is in the process of unlocking.\n     */\n    struct Unlock {\n        uint256 amount; // Amount of stake unlocking\n        uint256 unlockAt; // Block number the stake becomes withdrawable\n    }\n\n    function setUnlockDuration(uint256 _unlockDuration) external;\n\n    function setMinimumStakeProportion(uint32 _minimumStakeProportion) external;\n\n    function addStake(uint256 amount, address stakee) external;\n\n    function unlockStake(uint256 amount, address stakee) external returns (uint256);\n\n    function withdrawStake(address stakee) external;\n\n    function cancelUnlocking(uint256 amount, address stakee) external;\n\n    function calculateCapacityFromSeekerPower(uint256 seekerId) external view returns (uint256);\n\n    function calculateMaxAdditionalDelegatedStake(address stakee) external view returns (uint256);\n\n    function getTotalManagedStake() external view returns (uint256);\n\n    function getStakeEntry(\n        address stakee,\n        address staker\n    ) external view returns (StakeEntry memory);\n\n    function getStakeeTotalManagedStake(address stakee) external view returns (uint256);\n}\n"
    },
    "contracts/libraries/Manageable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an list of public managers who may be added or removed.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyManager`, which can be applied to your functions to restrict their use to\n * other contracts which have explicitly been added.\n */\nabstract contract Manageable is Ownable2StepUpgradeable {\n    /**\n     * @dev Tracks the managers added to this contract, where they key is the\n     * address of the managing contract, and the value is the block the manager was added in.\n     * We use this mapping to restrict access to those functions in a similar\n     * fashion to the onlyOwner construct.\n     */\n    mapping(address => uint256) public managers;\n\n    error OnlyManagers();\n    error ManagerCannotBeZeroAddress();\n\n    /**\n     * @notice Adds a manager to this contract. Only callable by the owner.\n     * @param manager The address of the manager contract.\n     */\n    function addManager(address manager) external onlyOwner {\n        if (manager == address(0)) {\n            revert ManagerCannotBeZeroAddress();\n        }\n        managers[manager] = block.number;\n    }\n\n    /**\n     * @notice Removes a manager from this contract. Only callable by the owner.\n     * @param manager The address of the manager contract.\n     */\n    function removeManager(address manager) external onlyOwner {\n        delete managers[manager];\n    }\n\n    /**\n     * @dev This modifier allows us to specify that certain contracts have\n     * special privileges to call restricted functions.\n     */\n    modifier onlyManager() {\n        if (managers[msg.sender] == 0) {\n            revert OnlyManagers();\n        }\n        _;\n    }\n\n    // Reserve storage slots for future variables\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/libraries/SyloUtils.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nerror ContractNameCannotBeEmpty();\nerror InterfaceIdCannotBeZeroBytes();\nerror TargetContractCannotBeZeroAddress(string name);\nerror TargetNotSupportInterface(string name, bytes4 interfaceId);\n\nlibrary SyloUtils {\n    /**\n     * @dev The maximum possible SYLO that exists in the network.\n     */\n    uint256 public constant MAX_SYLO = 10_000_000_000 ether;\n\n    /**\n     * @dev Percentages are expressed as a ratio where 100000 is the denominator.\n     * A large denominator allows for more precision, e.g representing 12.5%\n     * can be done as 12500 / 100000\n     */\n    uint32 public constant PERCENTAGE_DENOMINATOR = 100000;\n\n    /**\n     * @dev Multiply a value by a given percentage. Converts the provided\n     * uint128 value to uint256 to avoid any reverts on overflow.\n     * @param value The value to multiply.\n     * @param percentage The percentage, as a ratio of 100000.\n     */\n    function percOf(uint128 value, uint32 percentage) internal pure returns (uint256) {\n        return (uint256(value) * percentage) / PERCENTAGE_DENOMINATOR;\n    }\n\n    /**\n     * @dev Return a fraction as a percentage.\n     * @param numerator The numerator limited to a uint128 value to prevent\n     * phantom overflow.\n     * @param denominator The denominator.\n     * @return The percentage, as a ratio of 100000.\n     */\n    function asPerc(uint128 numerator, uint256 denominator) internal pure returns (uint32) {\n        return SafeCast.toUint32((uint256(numerator) * PERCENTAGE_DENOMINATOR) / denominator);\n    }\n\n    /**\n     * @dev Validate that a contract implements a given interface.\n     * @param name The name of the contract, used in error messages.\n     * @param target The address of the contract.\n     * @param interfaceId The interface ID to check.\n     */\n    function validateContractInterface(\n        string memory name,\n        address target,\n        bytes4 interfaceId\n    ) internal view {\n        if (bytes(name).length == 0) {\n            revert ContractNameCannotBeEmpty();\n        }\n        if (target == address(0)) {\n            revert TargetContractCannotBeZeroAddress(name);\n        }\n        if (interfaceId == bytes4(0)) {\n            revert InterfaceIdCannotBeZeroBytes();\n        }\n        if (!ERC165(target).supportsInterface(interfaceId)) {\n            revert TargetNotSupportInterface(name, interfaceId);\n        }\n    }\n}\n"
    },
    "contracts/mocks/TestFuturepassRegistrar.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\ncontract TestFuturepassRegistrar {\n    mapping(address => address) registrations;\n\n    function futurepassOf(address owner) external view returns (address) {\n        return registrations[owner];\n    }\n\n    function create(address owner) external returns (address) {\n        // ticketing contract does not actually care about futurepass\n        // address value, just needs to be non-zero\n        registrations[owner] = owner;\n        return owner;\n    }\n}\n"
    },
    "contracts/mocks/TestSeekers.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\n// Basic ERC721 contract with an unrestricted mint function.\n// Useful for mimicking the Seekers ERC721 contract for testing\n// purposes.\ncontract TestSeekers is ERC721 {\n    constructor() ERC721(\"Seekers\", \"SEEKERS\") {}\n\n    function mint(address to, uint256 tokenId) external {\n        _safeMint(to, tokenId);\n    }\n\n    function exists(uint256 tokenId) external view returns (bool) {\n        return _exists(tokenId);\n    }\n}\n"
    },
    "contracts/mocks/TestSyloUtils.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport \"../libraries/SyloUtils.sol\";\n\ncontract TestSyloUtils {\n    function percOf(uint128 value, uint32 percentage) public pure returns (uint256) {\n        return SyloUtils.percOf(value, percentage);\n    }\n\n    function asPerc(uint128 numerator, uint256 denominator) public pure returns (uint32) {\n        return SyloUtils.asPerc(numerator, denominator);\n    }\n\n    function validateContractInterface(\n        string memory name,\n        address target,\n        bytes4 interfaceId\n    ) public view {\n        SyloUtils.validateContractInterface(name, target, interfaceId);\n    }\n}\n"
    },
    "contracts/payments/SyloTicketing.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../Registries.sol\";\nimport \"../staking/Directory.sol\";\nimport \"../libraries/SyloUtils.sol\";\nimport \"../epochs/EpochsManager.sol\";\nimport \"../staking/StakingManager.sol\";\nimport \"./ticketing/RewardsManager.sol\";\nimport \"../AuthorizedAccounts.sol\";\nimport \"../interfaces/payments/ISyloTicketing.sol\";\nimport \"../interfaces/IFuturePassRegistrar.sol\";\n\n/**\n * @notice The SyloTicketing contract manages the Probabilistic\n * Micro-Payment Ticketing system that pays Nodes for providing the\n * Event Relay service.\n */\ncontract SyloTicketing is ISyloTicketing, Initializable, Ownable2StepUpgradeable, ERC165 {\n    /** ERC20 Sylo token contract.*/\n    IERC20 public _token;\n\n    /** Sylo Registries contract */\n    Registries public _registries;\n\n    /** Sylo Staking Manager contract */\n    StakingManager public _stakingManager;\n\n    /** Sylo Directory contract */\n    Directory public _directory;\n\n    /** Rewards Manager contract */\n    RewardsManager public _rewardsManager;\n\n    /**\n     * @notice Sylo Epochs Manager.\n     * @dev The ticketing parameters used when redeeming tickets\n     * will be read from this contract.\n     */\n    EpochsManager public _epochsManager;\n\n    /**\n     * @notice Sylo Authorized Accounts.\n     */\n    AuthorizedAccounts public _authorizedAccounts;\n\n    /**\n     * @notice Futurepass Registrar Pre-compile.\n     */\n    IFuturePassRegistrar public _futurepassRegistrar;\n\n    /**\n     * @notice The number of blocks a user must wait after calling \"unlock\"\n     * before they can withdraw their funds.\n     */\n    uint256 public unlockDuration;\n\n    /** @notice Mapping of user deposits */\n    mapping(address => Deposit) public deposits;\n\n    /** @notice Mapping of ticket hashes, used to check if a ticket has been redeemed */\n    mapping(bytes32 => bool) public usedTickets;\n\n    event UnlockDurationUpdated(uint256 unlockDuration);\n    event SenderPenaltyBurnt(address sender);\n    event Redemption(\n        uint256 indexed epochId,\n        address indexed redeemer,\n        address indexed sender,\n        address receiver,\n        uint256 generationBlock,\n        uint256 amount\n    );\n    event MultiReceiverRedemption(\n        uint256 indexed epochId,\n        address indexed redeemer,\n        address indexed sender,\n        address receiver,\n        uint256 generationBlock,\n        uint256 amount\n    );\n\n    error NoEsrowAndPenalty();\n    error UnlockingInProcess();\n    error UnlockingNotInProcess();\n    error UnlockingNotCompleted();\n    error EscrowAmountCannotBeZero();\n    error PenaltyAmountCannotBeZero();\n    error UnlockDurationCannotBeZero();\n    error AccountCannotBeZeroAddress();\n    error InvalidSenderSigningPermission();\n    error InvalidReceiverSigningPermission();\n\n    error TicketNotWinning();\n    error MissingFuturepassAccount(address receiver);\n    error TicketAlreadyUsed();\n    error TicketEpochNotFound();\n    error TicketAlreadyRedeemed();\n    error RedeemerCommitMismatch();\n    error InvalidSenderSignature();\n    error InvalidReceiverSignature();\n    error TokenCannotBeZeroAddress();\n    error TicketNotCreatedInTheEpoch();\n    error TicketCannotBeFromFutureBlock();\n    error TicketSenderCannotBeZeroAddress();\n    error TicketReceiverCannotBeZeroAddress();\n    error TicketRedeemerCannotBeZeroAddress();\n    error RedeemerMustHaveJoinedEpoch(uint256 epochId);\n\n    function initialize(\n        IERC20 token,\n        Registries registries,\n        StakingManager stakingManager,\n        Directory directory,\n        EpochsManager epochsManager,\n        RewardsManager rewardsManager,\n        AuthorizedAccounts authorizedAccounts,\n        IFuturePassRegistrar futurepassRegistrar,\n        uint256 _unlockDuration\n    ) external initializer {\n        if (address(token) == address(0)) {\n            revert TokenCannotBeZeroAddress();\n        }\n\n        SyloUtils.validateContractInterface(\n            \"Registries\",\n            address(registries),\n            type(IRegistries).interfaceId\n        );\n\n        SyloUtils.validateContractInterface(\n            \"StakingManager\",\n            address(stakingManager),\n            type(IStakingManager).interfaceId\n        );\n\n        SyloUtils.validateContractInterface(\n            \"Directory\",\n            address(directory),\n            type(IDirectory).interfaceId\n        );\n\n        SyloUtils.validateContractInterface(\n            \"EpochsManager\",\n            address(epochsManager),\n            type(IEpochsManager).interfaceId\n        );\n\n        SyloUtils.validateContractInterface(\n            \"RewardsManager\",\n            address(rewardsManager),\n            type(IRewardsManager).interfaceId\n        );\n\n        SyloUtils.validateContractInterface(\n            \"AuthorizedAccounts\",\n            address(authorizedAccounts),\n            type(IAuthorizedAccounts).interfaceId\n        );\n\n        if (_unlockDuration == 0) {\n            revert UnlockDurationCannotBeZero();\n        }\n\n        Ownable2StepUpgradeable.__Ownable2Step_init();\n\n        _token = token;\n        _registries = registries;\n        _stakingManager = stakingManager;\n        _directory = directory;\n        _epochsManager = epochsManager;\n        _rewardsManager = rewardsManager;\n        _authorizedAccounts = authorizedAccounts;\n        _futurepassRegistrar = futurepassRegistrar;\n\n        unlockDuration = _unlockDuration;\n    }\n\n    /**\n     * @notice Returns true if the contract implements the interface defined by\n     * `interfaceId` from ERC165.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(ISyloTicketing).interfaceId;\n    }\n\n    /**\n     * @notice Set the unlock duration for deposits. Only callable\n     * by the owner.\n     * @param _unlockDuration The unlock duration in blocks.\n     */\n    function setUnlockDuration(uint256 _unlockDuration) external onlyOwner {\n        if (_unlockDuration == 0) {\n            revert UnlockDurationCannotBeZero();\n        }\n\n        unlockDuration = _unlockDuration;\n        emit UnlockDurationUpdated(_unlockDuration);\n    }\n\n    /**\n     * @notice Use this function to deposit funds into the\n     * escrow. This will fail if the deposit is currently being\n     * unlocked.\n     * @param amount The amount in SOLO to add to the escrow.\n     * @param account The address of the account holding the escrow.\n     */\n    function depositEscrow(uint256 amount, address account) external {\n        if (amount == 0) {\n            revert EscrowAmountCannotBeZero();\n        }\n        if (account == address(0)) {\n            revert AccountCannotBeZeroAddress();\n        }\n\n        Deposit storage deposit = getDeposit(account);\n        if (deposit.unlockAt != 0) {\n            revert UnlockingInProcess();\n        }\n\n        deposit.escrow = deposit.escrow + amount;\n\n        SafeERC20.safeTransferFrom(_token, msg.sender, address(this), amount);\n    }\n\n    /**\n     * @notice Use this function to deposit funds into the\n     * penalty. This will fail if the deposit is currently being\n     * unlocked.\n     * @param amount The amount in SOLO to add to the escrow.\n     * @param account The address of the account holding the penalty.\n     */\n    function depositPenalty(uint256 amount, address account) external {\n        if (amount == 0) {\n            revert PenaltyAmountCannotBeZero();\n        }\n        if (account == address(0)) {\n            revert AccountCannotBeZeroAddress();\n        }\n\n        Deposit storage deposit = getDeposit(account);\n        if (deposit.unlockAt != 0) {\n            revert UnlockingInProcess();\n        }\n\n        deposit.penalty = deposit.penalty + amount;\n\n        SafeERC20.safeTransferFrom(_token, msg.sender, address(this), amount);\n    }\n\n    /**\n     * @notice Call this function to begin unlocking deposits. This function\n     * will fail if no deposit exists, or if the unlock process has\n     * already begun.\n     */\n    function unlockDeposits() external returns (uint256) {\n        Deposit storage deposit = getDeposit(msg.sender);\n\n        if (deposit.escrow == 0 && deposit.penalty == 0) {\n            revert NoEsrowAndPenalty();\n        }\n        if (deposit.unlockAt != 0) {\n            revert UnlockingInProcess();\n        }\n\n        deposit.unlockAt = block.number + unlockDuration;\n\n        return deposit.unlockAt;\n    }\n\n    /**\n     * @notice Call this function to cancel any deposit that is in the\n     * unlocking process.\n     */\n    function lockDeposits() external {\n        Deposit storage deposit = getDeposit(msg.sender);\n        if (deposit.unlockAt == 0) {\n            revert UnlockingNotInProcess();\n        }\n\n        delete deposit.unlockAt;\n    }\n\n    /**\n     * @notice Call this function once the unlock duration has\n     * elapsed in order to transfer the unlocked tokens to the caller's account.\n     */\n    function withdraw() external {\n        return withdrawTo(msg.sender);\n    }\n\n    /**\n     * @notice Call this function once the unlock duration has\n     * elapsed in order to transfer the unlocked tokens to the specified\n     * account.\n     * @param account The address of the account the tokens should be\n     * transferred to.\n     */\n    function withdrawTo(address account) public {\n        Deposit memory deposit = getDeposit(msg.sender);\n        if (deposit.unlockAt == 0) {\n            revert UnlockingNotInProcess();\n        }\n        if (deposit.unlockAt >= block.number) {\n            revert UnlockingNotCompleted();\n        }\n\n        uint256 amount = deposit.escrow + deposit.penalty;\n\n        // Reset deposit values to 0\n        delete deposits[msg.sender];\n\n        SafeERC20.safeTransfer(_token, account, amount);\n    }\n\n    /**\n     * @notice Nodes should call this function on completing an event\n     * delivery. This function will fail if the ticket is invalid or if the\n     * ticket is not a winner. Clients should calculate if the ticket is a\n     * winner locally, but can also use the public view functions:\n     * `requireValidWinningTicket` and `isWinningTicket` to check that a ticket\n     * is winning.\n     * @param ticket The ticket issued by the sender.\n     * @param redeemerRand The redeemer random value, generated by the Node prior\n     * to performing the event relay.\n     * @param senderSig The signature of the sender of the ticket.\n     * @param receiverSig The signature of the redeemer of the ticket.\n     */\n    function redeem(\n        Ticket calldata ticket,\n        uint256 redeemerRand,\n        bytes calldata senderSig,\n        bytes calldata receiverSig\n    ) external {\n        EpochsManager.Epoch memory epoch = _epochsManager.getEpoch(ticket.epochId);\n        if (ticket.generationBlock > block.number) {\n            revert TicketCannotBeFromFutureBlock();\n        }\n\n        bytes32 ticketHash = requireValidWinningTicket(\n            ticket,\n            redeemerRand,\n            senderSig,\n            receiverSig\n        );\n\n        usedTickets[ticketHash] = true;\n\n        uint256 directoryStake = _directory.getTotalStakeForStakee(\n            ticket.epochId,\n            ticket.redeemer\n        );\n        if (directoryStake == 0) {\n            revert RedeemerMustHaveJoinedEpoch(ticket.epochId);\n        }\n\n        _redeem(epoch, ticket);\n    }\n\n    /**\n     * @notice Nodes should call this function on completing a one-to-many event\n     * delivery. This function will fail if the ticket is invalid or if the\n     * ticket is not a winner. Additionally, the specified receiver must have\n     * a valid futurepass account associated with it. Clients should calculate\n     * if the ticket is a winner locally, but can also use the public view\n     * functions:\n     * `requireValidWinningMultiReceiverTicket` and `isWinningTicket` to check\n     * that a ticket is winning.\n     * @param ticket The ticket issued by the sender.\n     * @param redeemerRand The redeemer random value, generated by the Node prior\n     * to performing the event relay.\n     * @param receiver A valid receiver of the the relay.\n     * @param senderSig The signature of the sender of the ticket.\n     * @param receiverSig The signature of the redeemer of the ticket.\n     */\n    function redeemMultiReceiver(\n        MultiReceiverTicket calldata ticket,\n        uint256 redeemerRand,\n        User calldata receiver,\n        bytes calldata senderSig,\n        bytes calldata receiverSig\n    ) external {\n        EpochsManager.Epoch memory epoch = _epochsManager.getEpoch(ticket.epochId);\n        if (ticket.generationBlock > block.number) {\n            revert TicketCannotBeFromFutureBlock();\n        }\n\n        (, bytes32 ticketReceiverHash) = requireValidWinningMultiReceiverTicket(\n            ticket,\n            receiver,\n            redeemerRand,\n            senderSig,\n            receiverSig\n        );\n\n        usedTickets[ticketReceiverHash] = true;\n\n        uint256 directoryStake = _directory.getTotalStakeForStakee(\n            ticket.epochId,\n            ticket.redeemer\n        );\n        if (directoryStake == 0) {\n            revert RedeemerMustHaveJoinedEpoch(ticket.epochId);\n        }\n\n        _redeemMultiReceiver(epoch, ticket, receiver.main);\n    }\n\n    function _redeem(EpochsManager.Epoch memory epoch, Ticket calldata ticket) internal {\n        uint256 rewardAmount = rewardRedeemer(epoch, ticket.sender, ticket.redeemer);\n\n        emit Redemption(\n            ticket.epochId,\n            ticket.redeemer,\n            ticket.sender.main,\n            ticket.receiver.main,\n            ticket.generationBlock,\n            rewardAmount\n        );\n    }\n\n    function _redeemMultiReceiver(\n        EpochsManager.Epoch memory epoch,\n        MultiReceiverTicket calldata ticket,\n        address receiver\n    ) internal {\n        uint256 rewardAmount = rewardRedeemer(epoch, ticket.sender, ticket.redeemer);\n\n        emit MultiReceiverRedemption(\n            ticket.epochId,\n            ticket.redeemer,\n            ticket.sender.main,\n            receiver,\n            ticket.generationBlock,\n            rewardAmount\n        );\n    }\n\n    function rewardRedeemer(\n        EpochsManager.Epoch memory epoch,\n        User calldata sender,\n        address redeemer\n    ) internal returns (uint256) {\n        Deposit storage deposit = getDeposit(sender.main);\n\n        uint256 amount;\n\n        if (epoch.faceValue > deposit.escrow) {\n            amount = deposit.escrow;\n            incrementRewardPool(redeemer, deposit, amount);\n            SafeERC20.safeTransfer(\n                _token,\n                address(0x000000000000000000000000000000000000dEaD),\n                deposit.penalty\n            );\n\n            delete deposit.penalty;\n            emit SenderPenaltyBurnt(sender.main);\n        } else {\n            amount = epoch.faceValue;\n            incrementRewardPool(redeemer, deposit, amount);\n        }\n\n        return amount;\n    }\n\n    /**\n     * @notice Call this function to check if a ticket is valid and is\n     * a winning ticket. It will fail if the ticket is invalid or is not\n     * a winner. A ticket is invalid if:\n     *      - The sender or redeemer addresses are null\n     *      - The ticket has already been redeemed.\n     *      - The secret random value of the sender does not match the commit\n     *        in the ticket.\n     *      - The signatures are invalid.\n     * @param ticket The ticket issued by the sender.\n     * @param redeemerRand The redeemer random value, generated by the Node prior\n     * to performing the event relay.\n     * @param senderSig The signature of the sender of the ticket.\n     * @param receiverSig The signature of the redeemer of the ticket.\n     * @return ticketHash The hash of the ticket. Should match the hash generated\n     * by `getTicketHash`.\n     */\n    function requireValidWinningTicket(\n        Ticket memory ticket,\n        uint256 redeemerRand,\n        bytes calldata senderSig,\n        bytes calldata receiverSig\n    ) public view returns (bytes32 ticketHash) {\n        if (ticket.sender.main == address(0)) {\n            revert TicketSenderCannotBeZeroAddress();\n        }\n        if (ticket.receiver.main == address(0)) {\n            revert TicketReceiverCannotBeZeroAddress();\n        }\n        if (ticket.redeemer == address(0)) {\n            revert TicketRedeemerCannotBeZeroAddress();\n        }\n\n        ticketHash = getTicketHash(ticket);\n        if (usedTickets[ticketHash]) {\n            revert TicketAlreadyRedeemed();\n        }\n\n        // validate the redeemer has knowledge of the redeemer rand\n        if (createCommit(ticket.generationBlock, redeemerRand) != ticket.redeemerCommit) {\n            revert RedeemerCommitMismatch();\n        }\n\n        if (!hasSigningPermission(ticket.sender, ticket.generationBlock)) {\n            revert InvalidSenderSigningPermission();\n        }\n        if (!hasSigningPermission(ticket.receiver, ticket.generationBlock)) {\n            revert InvalidReceiverSigningPermission();\n        }\n\n        if (!isValidTicketSig(ticket.sender, senderSig, ticketHash)) {\n            revert InvalidSenderSignature();\n        }\n        if (!isValidTicketSig(ticket.receiver, receiverSig, ticketHash)) {\n            revert InvalidReceiverSignature();\n        }\n\n        if (\n            !isWinningTicket(\n                senderSig,\n                receiverSig,\n                ticket.epochId,\n                ticket.generationBlock,\n                redeemerRand\n            )\n        ) {\n            revert TicketNotWinning();\n        }\n    }\n\n    /**\n     * @notice Call this function to check if a multi receiver ticket is valid and is\n     * a winning ticket. It will fail if the ticket is invalid or is not\n     * a winner. A ticket is invalid if:\n     *      - The sender, receiver or redeemer addresses are null\n     *      - The receiver does not have a valid futurepass account\n     *      - The ticket has already been redeemed.\n     *      - The secret random value of the redeemer does not match the commit\n     *        in the ticket.\n     *      - The signatures are invalid.\n     * @param ticket The ticket issued by the sender.\n     * @param receiver The receiver associated with the ticket.\n     * @param redeemerRand The redeemer random value, generated by the Node prior\n     * to performing the event relay.\n     * @param senderSig The signature of the sender of the ticket.\n     * @param receiverSig The signature of the redeemer of the ticket.\n     */\n    function requireValidWinningMultiReceiverTicket(\n        MultiReceiverTicket memory ticket,\n        User calldata receiver,\n        uint256 redeemerRand,\n        bytes calldata senderSig,\n        bytes calldata receiverSig\n    ) public view returns (bytes32 ticketHash, bytes32 ticketReceiverHash) {\n        if (ticket.sender.main == address(0)) {\n            revert TicketSenderCannotBeZeroAddress();\n        }\n        if (receiver.main == address(0)) {\n            revert TicketReceiverCannotBeZeroAddress();\n        }\n        if (ticket.redeemer == address(0)) {\n            revert TicketRedeemerCannotBeZeroAddress();\n        }\n\n        address futurepassAccount = _futurepassRegistrar.futurepassOf(receiver.main);\n        if (futurepassAccount == address(0)) {\n            revert MissingFuturepassAccount(receiver.main);\n        }\n\n        // There are two hashes create. The first hash is signed by the\n        // sender and receiver, and is primarily used to validate these actors\n        // agreed on the contents of the ticket.\n        // The second hash is to prevent re-use. In a multi-receiver context,\n        // the same ticket can be re-used amongst many receiver, but should\n        // only be used ONCE per futurepass account. Thus the second hash\n        // additionally appends the futurepass address as well.\n        ticketHash = getMultiReceiverTicketHash(ticket);\n        ticketReceiverHash = keccak256(abi.encodePacked(ticketHash, futurepassAccount));\n        if (usedTickets[ticketReceiverHash]) {\n            revert TicketAlreadyRedeemed();\n        }\n\n        // validate the redeemer has knowledge of the redeemer rand\n        if (createCommit(ticket.generationBlock, redeemerRand) != ticket.redeemerCommit) {\n            revert RedeemerCommitMismatch();\n        }\n\n        if (!hasSigningPermission(ticket.sender, ticket.generationBlock)) {\n            revert InvalidSenderSigningPermission();\n        }\n        if (!hasSigningPermission(receiver, ticket.generationBlock)) {\n            revert InvalidReceiverSigningPermission();\n        }\n\n        if (!isValidTicketSig(ticket.sender, senderSig, ticketHash)) {\n            revert InvalidSenderSignature();\n        }\n        if (!isValidTicketSig(receiver, receiverSig, ticketHash)) {\n            revert InvalidReceiverSignature();\n        }\n\n        if (\n            !isWinningTicket(\n                senderSig,\n                receiverSig,\n                ticket.epochId,\n                ticket.generationBlock,\n                redeemerRand\n            )\n        ) {\n            revert TicketNotWinning();\n        }\n\n        return (ticketHash, ticketReceiverHash);\n    }\n\n    function hasSigningPermission(\n        User memory user,\n        uint256 generationBlock\n    ) internal view returns (bool) {\n        if (user.delegated == address(0)) {\n            return true;\n        }\n\n        IAuthorizedAccounts.Permission permission = IAuthorizedAccounts.Permission.PersonalSign;\n        return\n            _authorizedAccounts.validatePermission(\n                user.main,\n                user.delegated,\n                permission,\n                generationBlock\n            );\n    }\n\n    function createCommit(uint256 generationBlock, uint256 rand) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(keccak256(abi.encodePacked(generationBlock, rand))));\n    }\n\n    function getDeposit(address account) private view returns (Deposit storage) {\n        return deposits[account];\n    }\n\n    function isValidTicketSig(\n        User memory user,\n        bytes memory sig,\n        bytes32 ticketHash\n    ) internal pure returns (bool) {\n        address signer = address(0);\n        if (user.delegated != address(0)) {\n            signer = user.delegated;\n        } else {\n            signer = user.main;\n        }\n        bytes32 ethHash = ECDSA.toEthSignedMessageHash(ticketHash);\n        return ECDSA.recover(ethHash, sig) == signer;\n    }\n\n    /**\n     * @notice Use this function to check if a ticket is winning.\n     * @param senderSig The signature of the sender of the ticket.\n     * @param receiverSig The signature of the receiver of the ticket.\n     * @param epochId The epochId of the ticket.\n     * @param generationBlock The generationBlock of the ticket.\n     * @param redeemerRand The redeemer random value, generated by the Node prior\n     * to performing the event relay.\n     * @return True if a ticket is a winner.\n     */\n    function isWinningTicket(\n        bytes memory senderSig,\n        bytes memory receiverSig,\n        uint256 epochId,\n        uint256 generationBlock,\n        uint256 redeemerRand\n    ) public view returns (bool) {\n        uint256 winProb = calculateWinningProbability(epochId, generationBlock);\n        // bitshift the winProb to a 256 bit value to allow comparison to a 32 byte hash\n        uint256 prob = (uint256(winProb) << 128) | uint256(winProb);\n        return uint256(keccak256(abi.encodePacked(senderSig, receiverSig, redeemerRand))) < prob;\n    }\n\n    /**\n     * @notice This function calculates the probability of a ticket winning at\n     * the block that this function was called. A ticket's winning probability\n     * will decay every block since its issuance. The amount of decay will depend\n     * on the decay rate parameter of the epoch the ticket was generated in.\n     * @param epochId The epochId of the ticket.\n     * @param generationBlock The generationBlock of the ticket.\n     */\n    function calculateWinningProbability(\n        uint256 epochId,\n        uint256 generationBlock\n    ) public view returns (uint128) {\n        EpochsManager.Epoch memory epoch = _epochsManager.getEpoch(epochId);\n        if (epoch.startBlock == 0) {\n            revert TicketEpochNotFound();\n        }\n\n        if (\n            generationBlock < epoch.startBlock ||\n            (epoch.endBlock > 0 && generationBlock >= epoch.endBlock)\n        ) {\n            revert TicketNotCreatedInTheEpoch();\n        }\n\n        uint256 elapsedDuration = block.number - generationBlock;\n\n        // Ticket has completely expired\n        if (elapsedDuration >= epoch.ticketDuration) {\n            return 0;\n        }\n\n        uint256 maxDecayValue = SyloUtils.percOf(epoch.baseLiveWinProb, epoch.decayRate);\n\n        // determine the amount of probability that has actually decayed\n        // by multiplying the maximum decay value against ratio of the tickets elapsed duration\n        // vs the actual ticket duration. The max decay value is calculated from a fraction of a\n        // uint128 value so we cannot phantom overflow here\n        uint256 decayedProbability = (maxDecayValue * elapsedDuration) / epoch.ticketDuration;\n\n        // calculate the remaining probability by subtracting the decayed probability\n        // from the base\n        return epoch.baseLiveWinProb - SafeCast.toUint128(decayedProbability);\n    }\n\n    /**\n     * @notice Returns the hash of the ticket. Takes all fields in a ticket\n     * as inputs to the hash.\n     * @return A byte-array representing the hash.\n     */\n    function getTicketHash(Ticket memory ticket) public pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    ticket.epochId,\n                    ticket.sender.main,\n                    ticket.receiver.main,\n                    ticket.redeemer,\n                    ticket.generationBlock,\n                    ticket.redeemerCommit\n                )\n            );\n    }\n\n    /**\n     * @notice Returns the hash of a multi receiver ticket. Takes all fields in\n     * a ticket as inputs to the hash, as well as a specific receiver.\n     * @return A byte-array representing the hash.\n     */\n    function getMultiReceiverTicketHash(\n        MultiReceiverTicket memory ticket\n    ) public pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    ticket.epochId,\n                    ticket.sender.main,\n                    ticket.redeemer,\n                    ticket.generationBlock,\n                    ticket.redeemerCommit\n                )\n            );\n    }\n\n    function incrementRewardPool(\n        address stakee,\n        Deposit storage deposit,\n        uint256 amount\n    ) internal {\n        deposit.escrow = deposit.escrow - amount;\n\n        SafeERC20.safeTransfer(_token, address(_rewardsManager), amount);\n        _rewardsManager.incrementRewardPool(stakee, amount);\n    }\n}\n"
    },
    "contracts/payments/ticketing/RewardsManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport \"abdk-libraries-solidity/ABDKMath64x64.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../../libraries/SyloUtils.sol\";\nimport \"../../libraries/Manageable.sol\";\nimport \"../../epochs/EpochsManager.sol\";\nimport \"../../staking/StakingManager.sol\";\nimport \"../../interfaces/epochs/IEpochsManager.sol\";\nimport \"../../interfaces/staking/IStakingManager.sol\";\nimport \"../../interfaces/payments/ticketing/IRewardsManager.sol\";\n\n/**\n * @notice Handles epoch based reward pools that are incremented from redeeming tickets.\n * Nodes use this contract to set up their reward pool for the next epoch,\n * and stakers use this contract to track and claim staking rewards.\n * @dev After deployment, the SyloTicketing contract should be\n * set up as a manager to be able to call certain restricted functions.\n */\ncontract RewardsManager is IRewardsManager, Initializable, Manageable, ERC165 {\n    uint256 internal constant ONE_SYLO = 1 ether;\n\n    // 64x64 Fixed point representation of 1 SYLO (10**18 >> 64)\n    int128 internal constant ONE_SYLO_FIXED = 18446744073709551616000000000000000000;\n\n    uint256 internal constant MAX_INT64 = 9223372036854775807;\n\n    /** ERC20 Sylo token contract. */\n    IERC20 public _token;\n\n    /** Sylo Staking Manager contract. */\n    StakingManager public _stakingManager;\n\n    /** Sylo Epochs Manager. */\n    EpochsManager public _epochsManager;\n\n    /**\n     * @dev Each node will manage a cumulative reward factor (CRF) that is incremented\n     * whenever a ticket is redeemed. This factor acts as a single value\n     * that can be used to calculate any particular staker's reward share. This\n     * prevents the need to individually track each staker's proportion, and also allows\n     * a claim calculation to be performed without iterating through every epoch.\n     *\n     * The CRF is calculated as CRF = CRF + Reward / TotalStake.\n     */\n    mapping(address => int128) private cumulativeRewardFactors;\n\n    /**\n     * @notice Tracks the last epoch a delegated staker made a reward claim in.\n     * The key to this mapping is a hash of the Node's address and the delegated\n     * stakers address.\n     */\n    mapping(bytes32 => LastClaim) public lastClaims;\n\n    /**\n     * @notice Tracks each Nodes total pending rewards in SOLOs. This\n     * value is accumulated as Node's redeem tickets. Rewards are pending if the\n     * distribution amongst the stakers has not been accounted for yet. Pending rewards\n     * are transferred to unclaimed rewards once the the staker's share has been\n     * calculated.\n     */\n    mapping(address => uint256) public pendingRewards;\n\n    /**\n     * @notice Tracks rewards for stakers after the stakers share has been calculated,\n     * but has not actually been claimed by the staker.\n     * The node fee reward is also added to the node's unclaimedStakingRewards.\n     */\n    mapping(bytes32 => uint256) public unclaimedStakingRewards;\n\n    /**\n     * @notice Tracks each Node's most recently active reward pool\n     */\n    mapping(address => uint256) public latestActiveRewardPools;\n\n    /**\n     * @notice Tracks total accumulated rewards in each epoch\n     */\n    mapping(uint256 => uint256) public totalEpochRewards;\n\n    /**\n     * @notice Tracks total accumulated staking rewards in each epoch\n     */\n    mapping(uint256 => uint256) public totalEpochStakingRewards;\n\n    /**\n     * @notice Tracks each reward pool initialized by a Node. The key to this map\n     * is derived from the epochId and the Node's address.\n     */\n    mapping(bytes32 => RewardPool) public rewardPools;\n\n    error NoRewardToClaim();\n    error AmountCannotBeZero();\n    error RewardPoolNotExist();\n    error RewardPoolAlreadyExist();\n    error DoNotAllowZeroAddress();\n    error TokenCannotBeZeroAddress();\n    error NoStakeToCreateRewardPool();\n    error StakeeCannotBeZeroAddress();\n    error StakerCannotBeZeroAddress();\n    error StakerKeyCannotBeZeroBytes();\n    error InvalidFixedPointResult();\n    error NextRewardPoolAlreadyActive();\n\n    function initialize(\n        IERC20 token,\n        StakingManager stakingManager,\n        EpochsManager epochsManager\n    ) external initializer {\n        if (address(token) == address(0)) {\n            revert TokenCannotBeZeroAddress();\n        }\n\n        SyloUtils.validateContractInterface(\n            \"StakingManager\",\n            address(stakingManager),\n            type(IStakingManager).interfaceId\n        );\n\n        SyloUtils.validateContractInterface(\n            \"EpochsManager\",\n            address(epochsManager),\n            type(IEpochsManager).interfaceId\n        );\n\n        Ownable2StepUpgradeable.__Ownable2Step_init();\n\n        _token = token;\n        _epochsManager = epochsManager;\n        _stakingManager = stakingManager;\n    }\n\n    /**\n     * @notice Returns true if the contract implements the interface defined by\n     * `interfaceId` from ERC165.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IRewardsManager).interfaceId;\n    }\n\n    /**\n     * @notice Returns the key used to index a reward pool. The key is a hash of\n     * the epochId and Node's address.\n     * @param epochId The epoch ID the reward pool was created in.\n     * @param stakee The address of the Node.\n     * @return A byte-array representing the reward pool key.\n     */\n    function getRewardPoolKey(uint256 epochId, address stakee) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(epochId, stakee));\n    }\n\n    /**\n     * @notice Returns the key used to index staking claims. The key is a hash of\n     * the Node's address and the staker's address.\n     * @param stakee The address of the Node.\n     * @param staker The address of the stake.\n     * @return A byte-array representing the key.\n     */\n    function getStakerKey(address stakee, address staker) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(stakee, staker));\n    }\n\n    /**\n     * @notice Retrieve the reward pool initialized by the given node, at the specified\n     * epoch.\n     * @param epochId The ID of the epoch the reward pool was initialized in.\n     * @param stakee The address of the Node.\n     * @return The reward pool.\n     */\n    function getRewardPool(\n        uint256 epochId,\n        address stakee\n    ) public view returns (RewardPool memory) {\n        return rewardPools[getRewardPoolKey(epochId, stakee)];\n    }\n\n    /**\n     * @notice Retrieve the total accumulated reward that will be distributed to a Node's\n     * delegated stakers for a given epoch.\n     * @param epochId The ID of the epoch the reward pool was initialized in.\n     * @param stakee The address of the Node.\n     * @return The total accumulated staker reward in SOLO.\n     */\n    function getRewardPoolStakersTotal(\n        uint256 epochId,\n        address stakee\n    ) external view returns (uint256) {\n        return rewardPools[getRewardPoolKey(epochId, stakee)].stakersRewardTotal;\n    }\n\n    /**\n     * @notice Retrieve the total active stake that will be used for a Node's reward\n     * pool in a given epoch.\n     * @param epochId The ID of the epoch the reward pool was initialized in.\n     * @param stakee The address of the Node.\n     * @return The total active stake for that reward pool in SOLO.\n     */\n    function getRewardPoolActiveStake(\n        uint256 epochId,\n        address stakee\n    ) external view returns (uint256) {\n        return rewardPools[getRewardPoolKey(epochId, stakee)].totalActiveStake;\n    }\n\n    /**\n     * @notice Retrieve the total pending staking reward allocated to a Node's\n     * stakers.\n     * @param stakee The address of the Node.\n     * @return The total pending staking reward in SOLO.\n     */\n    function getPendingRewards(address stakee) external view returns (uint256) {\n        return pendingRewards[stakee];\n    }\n\n    /**\n     * @notice Retrieves the ID of the epoch in which a staker last made their\n     * staking claim.\n     * @param stakee The address of the Node.\n     * @param staker The address of the staker.\n     * @return The ID of the epoch.\n     */\n    function getLastClaim(\n        address stakee,\n        address staker\n    ) external view returns (LastClaim memory) {\n        return lastClaims[getStakerKey(stakee, staker)];\n    }\n\n    /**\n     * @notice Retrieves the total accumulated rewards for a specific epoch.\n     * @param epochId The epoch id.\n     * @return The total reward in that epoch, including staking rewards and fee\n     * reward.\n     */\n    function getTotalEpochRewards(uint256 epochId) external view returns (uint256) {\n        return totalEpochRewards[epochId];\n    }\n\n    /**\n     * @notice Retrieves the total accumulated rewards for stakers in a specific epoch.\n     * @param epochId The epoch id.\n     * @return The total staking reward in that epoch.\n     */\n    function getTotalEpochStakingRewards(uint256 epochId) external view returns (uint256) {\n        return totalEpochStakingRewards[epochId];\n    }\n\n    /**\n     * @notice This is used by Nodes to initialize their reward pool for\n     * the next epoch. This function will revert if the caller has no stake, or\n     * if the reward pool has already been initialized. The total active stake\n     * for the next reward pool is calculated by summing up the total managed\n     * stake held by the RewardsManager contract.\n     */\n    function initializeNextRewardPool(address stakee) external onlyManager {\n        if (stakee == address(0)) {\n            revert StakeeCannotBeZeroAddress();\n        }\n\n        uint256 nextEpochId = _epochsManager.getNextEpochId();\n\n        RewardPool storage nextRewardPool = rewardPools[getRewardPoolKey(nextEpochId, stakee)];\n        if (nextRewardPool.initializedAt != 0) {\n            revert RewardPoolAlreadyExist();\n        }\n\n        uint256 totalStake = _stakingManager.getStakeeTotalManagedStake(stakee);\n        if (totalStake == 0) {\n            revert NoStakeToCreateRewardPool();\n        }\n\n        nextRewardPool.totalActiveStake = totalStake;\n\n        nextRewardPool.initializedAt = block.number;\n    }\n\n    /**\n     * @dev This function should be called by the Ticketing contract when a\n     * ticket is successfully redeemed. The face value of the ticket\n     * should be split between incrementing the node's reward balance,\n     * and the reward balance for the node's delegated stakers. The face value\n     * will be added to the current reward pool's balance. This function will\n     * fail if the Ticketing contract has not been set as a manager.\n     * @param stakee The address of the Node.\n     * @param amount The face value of the ticket in SOLO.\n     */\n    function incrementRewardPool(address stakee, uint256 amount) external onlyManager {\n        if (stakee == address(0)) {\n            revert StakeeCannotBeZeroAddress();\n        }\n        if (amount == 0) {\n            revert AmountCannotBeZero();\n        }\n\n        (uint256 epochId, IEpochsManager.Epoch memory currentEpoch) = _epochsManager\n            .getCurrentActiveEpoch();\n\n        RewardPool storage rewardPool = rewardPools[getRewardPoolKey(epochId, stakee)];\n        if (rewardPool.initializedAt == 0) {\n            revert RewardPoolNotExist();\n        }\n\n        // Update the latest active reward pool for the node to be this pool\n        if (latestActiveRewardPools[stakee] < epochId) {\n            latestActiveRewardPools[stakee] = epochId;\n        }\n\n        uint256 stakersReward = SyloUtils.percOf(\n            SafeCast.toUint128(amount),\n            currentEpoch.defaultPayoutPercentage\n        );\n\n        // transfer the node's fee reward to it's unclaimed reward value\n        unclaimedStakingRewards[getStakerKey(stakee, stakee)] =\n            unclaimedStakingRewards[getStakerKey(stakee, stakee)] +\n            (amount - stakersReward);\n\n        // update the value of the reward owed to the stakers\n        pendingRewards[stakee] = pendingRewards[stakee] + stakersReward;\n\n        // if this is the first ticket redeemed for this reward, set the initial\n        // CRF value for this pool\n        if (rewardPool.stakersRewardTotal == 0) {\n            rewardPool.initialCumulativeRewardFactor = cumulativeRewardFactors[stakee];\n        }\n\n        rewardPool.stakersRewardTotal = rewardPool.stakersRewardTotal + stakersReward;\n\n        // We preemptively prevent an overflow revert with the abdk library.\n        // Dividing the stakers reward with the pool's total active\n        // stake may produce a value that is greater than the maximum possible\n        // 64.64 fixed point value.\n        // This error is incredibly niche and unlikely to happen, so we just\n        // revert here as well (with a named error) and remediation involves\n        // just increasing the amount of stake a node has.\n        if (rewardPool.totalActiveStake * MAX_INT64 < stakersReward) {\n            revert InvalidFixedPointResult();\n        }\n\n        cumulativeRewardFactors[stakee] = ABDKMath64x64.add(\n            cumulativeRewardFactors[stakee],\n            ABDKMath64x64.div(\n                toFixedPointSYLO(stakersReward),\n                toFixedPointSYLO(rewardPool.totalActiveStake)\n            )\n        );\n\n        totalEpochRewards[epochId] = totalEpochRewards[epochId] + amount;\n        totalEpochStakingRewards[epochId] = totalEpochStakingRewards[epochId] + stakersReward;\n    }\n\n    /**\n     * @dev This function utilizes the cumulative reward factors, and the staker's\n     * value in stake to calculate the staker's share of the pending reward.\n     */\n    function calculatePendingClaim(\n        bytes32 stakerKey,\n        address stakee,\n        address staker\n    ) internal view returns (uint256) {\n        uint256 claim = calculateInitialClaim(stakerKey, stakee);\n\n        // find the first reward pool where their stake was active and had\n        // generated rewards\n        uint256 activeAt;\n        RewardPool memory initialActivePool;\n\n        uint256 currentEpochId = _epochsManager.currentIteration();\n\n        for (uint256 i = lastClaims[stakerKey].claimedAt + 1; i < currentEpochId; ++i) {\n            initialActivePool = rewardPools[getRewardPoolKey(i, stakee)];\n            // check if node initialized a reward pool for this epoch and\n            // gained rewards\n            if (initialActivePool.initializedAt > 0 && initialActivePool.stakersRewardTotal > 0) {\n                activeAt = i;\n                break;\n            }\n        }\n\n        if (activeAt == 0) {\n            return claim;\n        }\n\n        IStakingManager.StakeEntry memory stakeEntry = _stakingManager.getStakeEntry(\n            stakee,\n            staker\n        );\n\n        // We convert the staker amount to SYLO as the maximum uint256 value that\n        // can be used for the fixed point representation is 2^64-1.\n        int128 initialStake = toFixedPointSYLO(stakeEntry.amount);\n\n        int128 initialCumulativeRewardFactor = initialActivePool.initialCumulativeRewardFactor;\n\n        int128 finalCumulativeRewardFactor = getFinalCumulativeRewardFactor(\n            stakee,\n            currentEpochId\n        );\n\n        return\n            claim +\n            fromFixedPointSYLO(\n                ABDKMath64x64.mul(\n                    initialStake,\n                    ABDKMath64x64.sub(finalCumulativeRewardFactor, initialCumulativeRewardFactor)\n                )\n            );\n    }\n\n    /**\n     * Manually calculates the reward claim for the first epoch the claim is being\n     * made for. This manual calculation is necessary as claims are only made up\n     * to the previous epoch.\n     */\n    function calculateInitialClaim(\n        bytes32 stakerKey,\n        address stakee\n    ) internal view returns (uint256) {\n        LastClaim memory lastClaim = lastClaims[stakerKey];\n\n        // if we have already made a claim up to the previous epoch, then\n        // there is no need to calculate the initial claim\n        if (_epochsManager.currentIteration() == lastClaim.claimedAt) {\n            return 0;\n        }\n\n        RewardPool memory firstRewardPool = rewardPools[\n            getRewardPoolKey(lastClaim.claimedAt, stakee)\n        ];\n\n        // if there was no reward pool initialized for the first epoch,\n        // then there is no need to calculate the initial claim\n        if (firstRewardPool.totalActiveStake == 0) {\n            return 0;\n        }\n\n        return\n            (firstRewardPool.stakersRewardTotal * lastClaim.stake) /\n            firstRewardPool.totalActiveStake;\n    }\n\n    /**\n     * Determines the cumulative reward factor to use for claim calculations. The\n     * CRF will depend on when the Node last initialized a reward pool, and also when\n     * the staker last made their claim.\n     */\n    function getFinalCumulativeRewardFactor(\n        address stakee,\n        uint256 currentEpochId\n    ) internal view returns (int128) {\n        int128 finalCumulativeRewardFactor;\n\n        // Get the cumulative reward factor for the Node\n        // for the start of this epoch, since we only perform\n        // calculations up to the end of the previous epoch.\n        if (latestActiveRewardPools[stakee] < currentEpochId) {\n            // If the Node has not been active, then the final\n            // cumulative reward factor will just be the current one.\n            finalCumulativeRewardFactor = cumulativeRewardFactors[stakee];\n        } else {\n            // We are calculating the claim for an active epoch, the\n            // final cumulative reward factor will be taken from the start of this\n            // epoch (end of previous epoch).\n            RewardPool storage latestRewardPool = rewardPools[\n                getRewardPoolKey(latestActiveRewardPools[stakee], stakee)\n            ];\n            finalCumulativeRewardFactor = latestRewardPool.initialCumulativeRewardFactor;\n        }\n\n        return finalCumulativeRewardFactor;\n    }\n\n    /**\n     * @notice Call this function to calculate the total reward owed to a staker.\n     * This value will include all epochs since the last claim was made up to\n     * the previous epoch. This will also add any pending rewards to the\n     * final value as well.\n     * @dev This function will utilize the cumulative reward factor to perform the\n     * calculation, keeping the gas cost scaling of this function to a constant value.\n     * @param stakee The address of the Node.\n     * @param staker The address of the staker.\n     * @return The value of the reward owed to the staker in SOLO.\n     */\n    function calculateStakerClaim(address stakee, address staker) public view returns (uint256) {\n        if (stakee == address(0)) {\n            revert StakeeCannotBeZeroAddress();\n        }\n        if (staker == address(0)) {\n            revert StakerCannotBeZeroAddress();\n        }\n\n        bytes32 stakerKey = getStakerKey(stakee, staker);\n        uint256 pendingClaim = calculatePendingClaim(stakerKey, stakee, staker);\n\n        return pendingClaim + unclaimedStakingRewards[stakerKey];\n    }\n\n    /**\n     * Helper function to convert a uint256 value in SOLOs to a 64.64 fixed point\n     * representation in SYLOs while avoiding any possibility of overflow.\n     * Any remainders from converting SOLO to SYLO is explicitly handled to mitigate\n     * precision loss. The error when using this function is [-1/2^64, 0].\n     */\n    function toFixedPointSYLO(uint256 amount) internal pure returns (int128) {\n        int128 fullSylos = ABDKMath64x64.fromUInt(amount / ONE_SYLO);\n        int128 fracSylos = ABDKMath64x64.fromUInt(amount % ONE_SYLO); // remainder\n\n        return ABDKMath64x64.add(fullSylos, ABDKMath64x64.div(fracSylos, ONE_SYLO_FIXED));\n    }\n\n    /**\n     * Helper function to convert a 64.64 fixed point value in SYLOs to a uint256\n     * representation in SOLOs while avoiding any possibility of overflow.\n     */\n    function fromFixedPointSYLO(int128 amount) internal pure returns (uint256) {\n        uint256 fullSylos = ABDKMath64x64.toUInt(amount);\n        uint256 fullSolos = fullSylos * ONE_SYLO;\n\n        // calculate the value lost when converting the fixed point amount to a uint\n        int128 fracSylos = ABDKMath64x64.sub(amount, ABDKMath64x64.fromUInt(fullSylos));\n        uint256 fracSolos = ABDKMath64x64.toUInt(ABDKMath64x64.mul(fracSylos, ONE_SYLO_FIXED));\n\n        return fullSolos + fracSolos;\n    }\n\n    /**\n     * @notice Call this function to claim rewards as a staker. The\n     * SYLO tokens will be transferred to the caller's account. This function will\n     * fail if there exists no reward to claim. Note: Calling this will remove\n     * the current unclaimed reward from being used as stake in the next round.\n     * @param stakee The address of the Node to claim against.\n     */\n    function claimStakingRewards(address stakee) external returns (uint256) {\n        if (stakee == address(0)) {\n            revert StakeeCannotBeZeroAddress();\n        }\n\n        uint256 currentEpoch = _epochsManager.currentIteration();\n        if (getRewardPool(currentEpoch + 1, stakee).totalActiveStake > 0) {\n            revert NextRewardPoolAlreadyActive();\n        }\n\n        bytes32 stakerKey = getStakerKey(stakee, msg.sender);\n        uint256 pendingReward = calculatePendingClaim(stakerKey, stakee, msg.sender);\n\n        uint256 totalClaim = pendingReward + unclaimedStakingRewards[stakerKey];\n        if (totalClaim == 0) {\n            revert NoRewardToClaim();\n        }\n\n        delete unclaimedStakingRewards[stakerKey];\n        pendingRewards[stakee] = pendingRewards[stakee] - pendingReward;\n\n        updateLastClaim(stakee, msg.sender);\n\n        SafeERC20.safeTransfer(_token, msg.sender, totalClaim);\n\n        return totalClaim;\n    }\n\n    /**\n     * @notice This is called by the staking manager to transfer pending rewards\n     * to unclaimed rewards for a staker. This is required as the last used CRF\n     * needs to be updated whenever stake changes.\n     */\n    function updatePendingRewards(address stakee, address staker) external onlyManager {\n        uint256 currentEpoch = _epochsManager.currentIteration();\n        if (getRewardPool(currentEpoch + 1, stakee).totalActiveStake > 0) {\n            revert NextRewardPoolAlreadyActive();\n        }\n\n        bytes32 stakerKey = getStakerKey(stakee, staker);\n        uint256 pendingReward = calculatePendingClaim(stakerKey, stakee, staker);\n\n        pendingRewards[stakee] = pendingRewards[stakee] - pendingReward;\n\n        unclaimedStakingRewards[stakerKey] = unclaimedStakingRewards[stakerKey] + pendingReward;\n\n        updateLastClaim(stakee, staker);\n    }\n\n    function updateLastClaim(address stakee, address staker) internal {\n        bytes32 stakerKey = getStakerKey(stakee, staker);\n        LastClaim storage lastClaim = lastClaims[stakerKey];\n\n        uint256 claimAt = _epochsManager.currentIteration();\n\n        IStakingManager.StakeEntry memory stakeEntry = _stakingManager.getStakeEntry(\n            stakee,\n            staker\n        );\n\n        // If we have already updated the last claim for this epoch, then\n        // we skip updating it again.\n        if (lastClaim.claimedAt == claimAt) {\n            return;\n        }\n\n        lastClaim.claimedAt = claimAt;\n        lastClaim.stake = stakeEntry.amount;\n    }\n}\n"
    },
    "contracts/payments/ticketing/TicketingParameters.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../../libraries/SyloUtils.sol\";\nimport \"../../interfaces/payments/ticketing/ITicketingParameters.sol\";\n\n/**\n * @dev Persists the parameters for the ticketing mechanism. This contract is\n * read by the EpochManager. Extracting the parameters into another\n * contract is necessary to avoid a cyclic dependency between the ticketing\n * and epoch contracts.\n */\ncontract TicketingParameters is\n    ITicketingParameters,\n    Initializable,\n    Ownable2StepUpgradeable,\n    ERC165\n{\n    /** @notice The value of a winning ticket in SOLO. */\n    uint256 public faceValue;\n\n    /**\n     * @notice The probability of a ticket winning during the start of its lifetime.\n     * This is a uint128 value representing the numerator in the probability\n     * ratio where 2^128 - 1 is the denominator.\n     */\n    uint128 public baseLiveWinProb;\n\n    /**\n     * @notice The probability of a ticket winning after it has expired.\n     * This is a uint128 value representing the numerator in the probability\n     * ratio where 2^128 - 1 is the denominator. Note: Redeeming expired\n     * tickets is currently not supported.\n     */\n    uint128 public expiredWinProb;\n\n    /**\n     * @notice The length in blocks before a ticket is considered expired.\n     * The default initialization value is 80,000. This equates\n     * to roughly two weeks (15s per block).\n     */\n    uint256 public ticketDuration;\n\n    /**\n     * @notice A percentage value representing the proportion of the base win\n     * probability that will be decayed once a ticket has expired.\n     * Example: 80% decayRate indicates that a ticket will decay down to 20% of its\n     * base win probability upon reaching the block before its expiry.\n     * The value is expressed as a fraction of 100000.\n     */\n    uint32 public decayRate;\n\n    event FaceValueUpdated(uint256 faceValue);\n    event BaseLiveWinProbUpdated(uint128 baseLiveWinprob);\n    event ExpiredWinProbUpdated(uint128 expiredWinProb);\n    event TicketDurationUpdated(uint256 ticketDuration);\n    event DecayRateUpdated(uint32 decayRate);\n\n    error FaceValueCannotBeZero();\n    error TicketDurationCannotBeZero();\n\n    function initialize(\n        uint256 _faceValue,\n        uint128 _baseLiveWinProb,\n        uint128 _expiredWinProb,\n        uint32 _decayRate,\n        uint256 _ticketDuration\n    ) external initializer {\n        if (_faceValue == 0) {\n            revert FaceValueCannotBeZero();\n        }\n        if (_ticketDuration == 0) {\n            revert TicketDurationCannotBeZero();\n        }\n\n        Ownable2StepUpgradeable.__Ownable2Step_init();\n\n        faceValue = _faceValue;\n        baseLiveWinProb = _baseLiveWinProb;\n        expiredWinProb = _expiredWinProb;\n        decayRate = _decayRate;\n        ticketDuration = _ticketDuration;\n    }\n\n    /**\n     * @notice Returns true if the contract implements the interface defined by\n     * `interfaceId` from ERC165.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(ITicketingParameters).interfaceId;\n    }\n\n    /**\n     * @notice Set the face value for tickets in SOLO. Only callable by\n     * the contract owner.\n     * @param _faceValue The face value to set in SOLO.\n     */\n    function setFaceValue(uint256 _faceValue) external onlyOwner {\n        if (_faceValue == 0) {\n            revert FaceValueCannotBeZero();\n        }\n\n        faceValue = _faceValue;\n        emit FaceValueUpdated(_faceValue);\n    }\n\n    /**\n     * @notice Set the base live win probability of a ticket. Only callable by\n     * the contract owner.\n     * @param _baseLiveWinProb The probability represented as a value\n     * between 0 to 2**128 - 1.\n     */\n    function setBaseLiveWinProb(uint128 _baseLiveWinProb) external onlyOwner {\n        baseLiveWinProb = _baseLiveWinProb;\n        emit BaseLiveWinProbUpdated(_baseLiveWinProb);\n    }\n\n    /**\n     * @notice Set the expired win probability of a ticket. Only callable by\n     * the contract owner.\n     * @param _expiredWinProb The probability represented as a value\n     * between 0 to 2**128 - 1.\n     */\n    function setExpiredWinProb(uint128 _expiredWinProb) external onlyOwner {\n        expiredWinProb = _expiredWinProb;\n        emit ExpiredWinProbUpdated(_expiredWinProb);\n    }\n\n    /**\n     * @notice Set the decay rate of a ticket. Only callable by the\n     * the contract owner.\n     * @param _decayRate The decay rate as a percentage, where the\n     * denominator is 10000.\n     */\n    function setDecayRate(uint32 _decayRate) external onlyOwner {\n        decayRate = _decayRate;\n        emit DecayRateUpdated(_decayRate);\n    }\n\n    /**\n     * @notice Set the ticket duration of a ticket. Only callable by the\n     * contract owner.\n     * @param _ticketDuration The duration of a ticket in number of blocks.\n     */\n    function setTicketDuration(uint256 _ticketDuration) external onlyOwner {\n        if (_ticketDuration == 0) {\n            revert TicketDurationCannotBeZero();\n        }\n\n        ticketDuration = _ticketDuration;\n        emit TicketDurationUpdated(_ticketDuration);\n    }\n\n    /**\n     * @notice Retrieve the current ticketing parameters.\n     * @return faceValue The face value of a ticket in SOLO.\n     * @return baseLiveWinProb The base live win probability of a ticket.\n     * @return expiredWinProb The expired win probability of a ticket.\n     * @return ticketDuration The duration of a ticket in number of blocks.\n     * @return decayRate The decay rate of a ticket.\n     */\n    function getTicketingParameters()\n        external\n        view\n        returns (uint256, uint128, uint128, uint256, uint32)\n    {\n        return (faceValue, baseLiveWinProb, expiredWinProb, ticketDuration, decayRate);\n    }\n}\n"
    },
    "contracts/Registries.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\nimport \"./libraries/SyloUtils.sol\";\nimport \"./interfaces/IRegistries.sol\";\n\n/**\n * @notice This contract manages Registries for Nodes. A Registry is a\n * set of parameters configured by the Node itself. A Node is required\n * to have a valid Registry to be able to participate in the network.\n */\ncontract Registries is IRegistries, Initializable, Ownable2StepUpgradeable, IERC165 {\n    using ECDSA for bytes32;\n\n    /**\n     * @notice ERC721 contract for bridged Seekers. Used for verifying ownership\n     * of a seeker.\n     */\n    IERC721 public _rootSeekers;\n\n    /**\n     * @notice Tracks each Node's registry.\n     */\n    mapping(address => IRegistries.Registry) public registries;\n\n    /**\n     * @notice Tracks the node address that each seeker id is registered with\n     */\n    mapping(uint256 => address) public seekerRegistration;\n\n    /**\n     * @notice Tracks the address of every registered node.\n     */\n    address[] public nodes;\n\n    /**\n     * @notice Tracks nonces used when registering the seeker account\n     * to prevent signature re-use.\n     */\n    mapping(bytes32 => address) private signatureNonces;\n\n    /**\n     * @notice Payout percentage refers to the portion of a tickets reward\n     * that will be allocated to the Node's stakers. This is global, and is\n     * currently set for all Nodes.\n     */\n    uint32 public defaultPayoutPercentage;\n\n    event DefaultPayoutPercentageUpdated(uint32 defaultPayoutPercentage);\n\n    error NonceCannotBeReused();\n    error EndMustBeGreaterThanStart();\n    error PercentageCannotExceed100000();\n    error PublicEndpointCannotBeEmpty();\n    error SeekerAccountMustOwnSeekerId();\n    error SeekerAccountMustBeMsgSender();\n    error ProofNotSignedBySeekerAccount();\n    error RootSeekersCannotBeZeroAddress();\n    error SeekerAccountCannotBeZeroAddress();\n    error EndCannotExceedNumberOfNodes(uint256 nodeLength);\n\n    function initialize(\n        IERC721 rootSeekers,\n        uint32 _defaultPayoutPercentage\n    ) external initializer {\n        if (address(rootSeekers) == address(0)) {\n            revert RootSeekersCannotBeZeroAddress();\n        }\n        if (_defaultPayoutPercentage > 100000) {\n            revert PercentageCannotExceed100000();\n        }\n\n        Ownable2StepUpgradeable.__Ownable2Step_init();\n\n        _rootSeekers = rootSeekers;\n        defaultPayoutPercentage = _defaultPayoutPercentage;\n    }\n\n    /**\n     * @notice Returns true if the contract implements the interface defined by\n     * `interfaceId` from ERC165.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IRegistries).interfaceId;\n    }\n\n    /**\n     * @notice Set the global default payout percentage value. Only callable\n     * by the owner.\n     * @param _defaultPayoutPercentage The payout percentage as a value where the\n     * denominator is 100000.\n     */\n    function setDefaultPayoutPercentage(uint32 _defaultPayoutPercentage) external onlyOwner {\n        if (_defaultPayoutPercentage > 100000) {\n            revert PercentageCannotExceed100000();\n        }\n\n        defaultPayoutPercentage = _defaultPayoutPercentage;\n        emit DefaultPayoutPercentageUpdated(_defaultPayoutPercentage);\n    }\n\n    /**\n     * @notice Call this as a Node to set or update your Registry entry.\n     * @param publicEndpoint The public endpoint of your Node. Essential for\n     * clients to be able to retrieve additional information, such as\n     * an address to establish a p2p connection.\n     */\n    function register(string calldata publicEndpoint) external {\n        if (bytes(publicEndpoint).length == 0) {\n            revert PublicEndpointCannotBeEmpty();\n        }\n\n        // This is the nodes first registration\n        if (bytes(registries[msg.sender].publicEndpoint).length == 0) {\n            nodes.push(msg.sender);\n        }\n\n        registries[msg.sender].publicEndpoint = publicEndpoint;\n    }\n\n    function setSeekerAccount(\n        address seekerAccount,\n        uint256 seekerId,\n        bytes32 nonce,\n        bytes calldata signature\n    ) external {\n        if (seekerAccount == address(0)) {\n            revert SeekerAccountCannotBeZeroAddress();\n        }\n        if (signatureNonces[nonce] != address(0)) {\n            revert NonceCannotBeReused();\n        }\n\n        bytes memory proofMessage = getProofMessage(seekerId, msg.sender, nonce);\n        bytes32 ethProof = ECDSA.toEthSignedMessageHash(proofMessage);\n\n        if (ECDSA.recover(ethProof, signature) != seekerAccount) {\n            revert ProofNotSignedBySeekerAccount();\n        }\n\n        // Now verify the seeker account actually owns the seeker\n        address owner = _rootSeekers.ownerOf(seekerId);\n\n        if (seekerAccount != owner) {\n            revert SeekerAccountMustOwnSeekerId();\n        }\n\n        delete registries[seekerRegistration[seekerId]].seekerId;\n        delete registries[seekerRegistration[seekerId]].seekerAccount;\n\n        registries[msg.sender].seekerAccount = seekerAccount;\n        registries[msg.sender].seekerId = seekerId;\n\n        seekerRegistration[seekerId] = msg.sender;\n\n        signatureNonces[nonce] = seekerAccount;\n    }\n\n    function revokeSeekerAccount(address node) external {\n        Registry storage registry = registries[node];\n\n        if (registry.seekerAccount != msg.sender) {\n            revert SeekerAccountMustBeMsgSender();\n        }\n\n        delete registry.seekerAccount;\n        delete seekerRegistration[registry.seekerId];\n        delete registry.seekerId;\n    }\n\n    /**\n     * @notice Retrieve the registry associated with a Node.\n     * @param account The address of the Node.\n     * @return The Node's Registry.\n     */\n    function getRegistry(address account) external view returns (Registry memory) {\n        return registries[account];\n    }\n\n    /**\n     * @notice Retrieve all registered nodes.\n     * @return An array of node addresses.\n     */\n    function getNodes() external view returns (address[] memory) {\n        return nodes;\n    }\n\n    /**\n     * @notice Retrieves a list of registries. Takes in a\n     * a start and end indices to allow pagination.\n     * @param start The start index which is inclusive.\n     * @param end The end index which is exclusive.\n     * @return An array of Registries.\n     */\n    function getRegistries(\n        uint256 start,\n        uint256 end\n    ) external view returns (address[] memory, Registry[] memory) {\n        uint256 nodesLength = nodes.length;\n\n        if (end <= start) {\n            revert EndMustBeGreaterThanStart();\n        }\n        if (end > nodesLength) {\n            revert EndCannotExceedNumberOfNodes(nodesLength);\n        }\n\n        address[] memory _nodes = new address[](end - start);\n        Registry[] memory _registries = new Registry[](_nodes.length);\n\n        for (uint256 i = start; i < end; ++i) {\n            _nodes[i - start] = nodes[i];\n            _registries[i - start] = registries[nodes[i]];\n        }\n\n        return (_nodes, _registries);\n    }\n\n    /**\n     * @notice Returns the total number of registered nodes.\n     * @return The number of registered nodes.\n     */\n    function getTotalNodes() external view returns (uint256) {\n        return nodes.length;\n    }\n\n    /**\n     * @notice Helper function for deriving the proof message used to\n     * validate seeker ownership.\n     * @param seekerId The tokenId of the seeker used for operation.\n     * @param node The address of the node which that will be operated\n     * by the specified seeker.\n     * @param nonce The nonce used for this message.\n     */\n    function getProofMessage(\n        uint256 seekerId,\n        address node,\n        bytes32 nonce\n    ) public pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                unicode\" Hi frend! \\n\\n Signing this message proves that you're the owner of this Seeker NFT and allows your Seeker to be used to operate your Seeker's Node. It's a simple but important step to ensure smooth operation.\\n\\nThis request will not trigger a blockchain transaction or cost any gas fees.\\n\\n Your node's address: \",\n                Strings.toHexString(uint256(uint160(node)), 20),\n                unicode\"\\n\\n Your seeker id: \",\n                Strings.toString(seekerId),\n                unicode\"\\n\\n A unique random value which secures this message: \",\n                Strings.toHexString(uint256(nonce), 32)\n            );\n    }\n}\n"
    },
    "contracts/SeekerPowerOracle.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport \"./interfaces/ISeekerPowerOracle.sol\";\n\n/**\n * @notice Acts as a source of information for Seeker Powers. Allows setting\n * a Seeker's power level via a restricted oracle account call. Seeker Power can also\n * be set by any account if the correct Oracle signature proof is provided.\n */\ncontract SeekerPowerOracle is ISeekerPowerOracle, Initializable, Ownable2StepUpgradeable, ERC165 {\n    /**\n     * @notice The oracle account. This contract accepts any attestations of\n     * Seeker power that have been signed by this account.\n     */\n    address public oracle;\n\n    /**\n     * @notice Tracks nonce used when register the Seeker power to\n     * prevent signature re-use.\n     */\n    mapping(bytes32 => address) private proofNonces;\n\n    /**\n     * @notice Tracks the set of Seeker Power levels.\n     */\n    mapping(uint256 => uint256) public seekerPowers;\n\n    event SeekerPowerUpdated(uint256 indexed seekerId, uint256 indexed power);\n\n    error UnauthorizedRegisterSeekerPowerCall();\n    error NonceCannotBeReused();\n    error PowerCannotBeZero();\n    error OracleCannotBeZeroAddress();\n\n    function initialize(address _oracle) external initializer {\n        Ownable2StepUpgradeable.__Ownable2Step_init();\n\n        if (_oracle == address(0)) {\n            revert OracleCannotBeZeroAddress();\n        }\n\n        oracle = _oracle;\n    }\n\n    /**\n     * @notice Returns true if the contract implements the interface defined by\n     * `interfaceId` from ERC165.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(ISeekerPowerOracle).interfaceId;\n    }\n\n    /**\n     * @notice Sets the oracle account.\n     * @param _oracle The oracle account.\n     */\n    function setOracle(address _oracle) external onlyOwner {\n        oracle = _oracle;\n    }\n\n    /**\n     * @notice Registers a Seeker's power level. Only callable by the\n     * owner or the oracle account.\n     * @param seekerId The id of the Seeker.\n     * @param power The power level of the Seeker.\n     */\n    function registerSeekerPowerRestricted(uint256 seekerId, uint256 power) external {\n        if (msg.sender != oracle) {\n            revert UnauthorizedRegisterSeekerPowerCall();\n        }\n\n        if (power == 0) {\n            revert PowerCannotBeZero();\n        }\n\n        seekerPowers[seekerId] = power;\n        emit SeekerPowerUpdated(seekerId, power);\n    }\n\n    /**\n     * @notice Registers a Seeker's power level. Callable by any account\n     * but requires a proof signed by the oracle.\n     * @param seekerId The id of the Seeker.\n     * @param power The power level of the Seeker.\n     */\n    function registerSeekerPower(\n        uint256 seekerId,\n        uint256 power,\n        bytes32 nonce,\n        bytes calldata proof\n    ) external {\n        if (proofNonces[nonce] != address(0)) {\n            revert NonceCannotBeReused();\n        }\n\n        if (power == 0) {\n            revert PowerCannotBeZero();\n        }\n\n        bytes memory proofMessage = getProofMessage(seekerId, power, nonce);\n        bytes32 ecdsaHash = ECDSA.toEthSignedMessageHash(proofMessage);\n\n        if (ECDSA.recover(ecdsaHash, proof) != oracle) {\n            revert UnauthorizedRegisterSeekerPowerCall();\n        }\n\n        seekerPowers[seekerId] = power;\n        proofNonces[nonce] = oracle;\n\n        emit SeekerPowerUpdated(seekerId, power);\n    }\n\n    /**\n     * @notice Retrieves a Seeker's stored power level.\n     * @param seekerId The id of the Seeker.\n     */\n    function getSeekerPower(uint256 seekerId) external view returns (uint256) {\n        return seekerPowers[seekerId];\n    }\n\n    /**\n     * @notice Constructs a proof message for the oracle to sign.\n     * @param seekerId The id of the Seeker.\n     * @param power The power level of the Seeker.\n     */\n    function getProofMessage(\n        uint256 seekerId,\n        uint256 power,\n        bytes32 nonce\n    ) public pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                Strings.toString(seekerId),\n                \":\",\n                Strings.toString(power),\n                \":\",\n                Strings.toHexString(uint256(nonce), 32)\n            );\n    }\n}\n"
    },
    "contracts/staking/Directory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"./StakingManager.sol\";\nimport \"../libraries/SyloUtils.sol\";\nimport \"../libraries/Manageable.sol\";\nimport \"../interfaces/staking/IDirectory.sol\";\nimport \"../payments/ticketing/RewardsManager.sol\";\n\n/**\n * @notice The Directory contract constructs and manages a structure holding the current stakes,\n * which is queried against using the scan function. The scan function allows submitting\n * random points which will return a staked node's address in proportion to the stake it has.\n */\ncontract Directory is IDirectory, Initializable, Manageable, IERC165 {\n    /** Sylo Staking Manager contract */\n    StakingManager public _stakingManager;\n\n    /** Sylo Rewards Manager contract */\n    RewardsManager public _rewardsManager;\n\n    /**\n     * @notice The epoch ID of the current directory.\n     */\n    uint256 public currentDirectory;\n\n    /**\n     * @notice Tracks every directory, which will be indexed by an epoch ID\n     */\n    mapping(uint256 => EpochDirectory) public directories;\n\n    event CurrentDirectoryUpdated(uint256 indexed currentDirectory);\n\n    error NoStakeToJoinEpoch();\n    error StakeeAlreadyJoinedEpoch();\n    error StakeeCannotBeZeroAddress();\n    error NoJoiningStakeToJoinEpoch();\n\n    function initialize(\n        StakingManager stakingManager,\n        RewardsManager rewardsManager\n    ) external initializer {\n        SyloUtils.validateContractInterface(\n            \"StakingManager\",\n            address(stakingManager),\n            type(IStakingManager).interfaceId\n        );\n\n        SyloUtils.validateContractInterface(\n            \"RewardsManager\",\n            address(rewardsManager),\n            type(IRewardsManager).interfaceId\n        );\n\n        Ownable2StepUpgradeable.__Ownable2Step_init();\n\n        _stakingManager = stakingManager;\n        _rewardsManager = rewardsManager;\n    }\n\n    /**\n     * @notice Returns true if the contract implements the interface defined by\n     * `interfaceId` from ERC165.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IDirectory).interfaceId;\n    }\n\n    /**\n     * @notice This function should be called when a new epoch is initialized.\n     * This will set the current directory to the specified epoch. This is only\n     * callable by the owner of this contract, which should be the EpochsManager\n     * contract.\n     * @dev After deployment, the EpochsManager should immediately be set as\n     * the owner.\n     * @param epochId The ID of the specified epoch.\n     */\n    function setCurrentDirectory(uint256 epochId) external onlyManager {\n        currentDirectory = epochId;\n        emit CurrentDirectoryUpdated(epochId);\n    }\n\n    /**\n     * @notice This function is called by the epochs manager as a prerequisite to when the node joins the next epoch.\n     * @param stakee The address of the node.\n     * @param seekerId The seekerId of the Seeker that the node is\n     * registered with when joining the epoch. It is used to determine the nodes\n     * staking capacity based on its seeker power.\n     *\n     * @dev This will construct the directory as nodes join. The directory is constructed\n     * by creating a boundary value which is a sum of the current directory's total stake, and\n     * the current stakee's total stake, and pushing the new boundary into the entries array.\n     * The previous boundary and the current boundary essentially create a range, where if a\n     * random point were to fall within that range, it would belong to the respective stakee.\n     * The boundary value grows in size as each stakee joins, thus the directory array\n     * always remains sorted. This allows us to perform a binary search on the directory.\n     *\n     * Example\n     *\n     * Stakes: [ Alice/20, Bob/10, Carl/40, Dave/25 ]\n     * TotalStake: 95\n     *\n     * EpochDirectory:\n     *\n     *  |-----------|------|----------------|--------|\n     *     Alice/20  Bob/30     Carl/70      Dave/95\n     *\n     * The amount of stake that a node will join a directory with is dependent on its\n     * different capacity values. There are two distinct capacity values, one\n     * calculated from the seeker power, and another from the minimum stake\n     * proportion. The final staking amount will not exceed either capacities,\n     * and in the case that the current total stake exceeds both, then the final\n     * will be the minimum of the two values.\n     */\n    function joinNextDirectory(address stakee, uint256 seekerId) external onlyManager {\n        if (stakee == address(0)) {\n            revert StakeeCannotBeZeroAddress();\n        }\n\n        uint256 nextEpochId = currentDirectory + 1;\n\n        uint256 totalStake = _stakingManager.getStakeeTotalManagedStake(stakee);\n        if (totalStake == 0) {\n            revert NoStakeToJoinEpoch();\n        }\n\n        // staking capacity based on seeker power\n        uint256 seekerStakingCapacity = _stakingManager.calculateCapacityFromSeekerPower(seekerId);\n\n        // staking capacity based on the min staking proportion constant\n        uint256 minProportionStakingCapacity = _stakingManager.calculateCapacityFromMinStakingProportion(stakee);\n\n        uint256 joiningStake;\n        if (totalStake > seekerStakingCapacity && totalStake > minProportionStakingCapacity) {\n            joiningStake = Math.min(seekerStakingCapacity, minProportionStakingCapacity);\n        } else if (totalStake > seekerStakingCapacity) {\n            joiningStake = seekerStakingCapacity;\n        } else if (totalStake > minProportionStakingCapacity) {\n            joiningStake = minProportionStakingCapacity;\n        } else { // uncapped\n            joiningStake = totalStake;\n        }\n\n        if (joiningStake == 0) {\n            revert NoJoiningStakeToJoinEpoch();\n        }\n\n        if (directories[nextEpochId].stakes[stakee] > 0) {\n            revert StakeeAlreadyJoinedEpoch();\n        }\n\n        uint256 nextBoundary = directories[nextEpochId].totalStake + joiningStake;\n\n        directories[nextEpochId].entries.push(DirectoryEntry(stakee, nextBoundary));\n        directories[nextEpochId].stakes[stakee] = joiningStake;\n        directories[nextEpochId].totalStake = nextBoundary;\n    }\n\n    /**\n     * @notice Call this to perform a stake-weighted scan to find the Node assigned\n     * to the given point of the current directory.\n     * @param point The point, which will usually be a hash of a public key.\n     */\n    function scan(uint128 point) external view returns (address stakee) {\n        return _scan(point, currentDirectory);\n    }\n\n    /**\n     * @notice Call this to perform a stake-weighted scan to find the Node assigned\n     * to the given point of the requested directory.\n     * @param point The point, which will usually be a hash of a public key.\n     * @param epochId The epoch id associated with the directory to scan.\n     */\n    function scanWithEpochId(\n        uint128 point,\n        uint256 epochId\n    ) external view returns (address stakee) {\n        return _scan(point, epochId);\n    }\n\n    /**\n     * @notice Call this to perform a stake-weighted scan to find the Node assigned\n     * to the given point of the requested directory (internal).\n     * @dev The current implementation will perform a binary search through\n     * the directory. This can allow gas costs to be low if this needs to be\n     * used in a transaction.\n     * @param point The point, which will usually be a hash of a public key.\n     * @param epochId The epoch id associated with the directory to scan.\n     */\n    function _scan(uint128 point, uint256 epochId) internal view returns (address stakee) {\n        uint256 entryLength = directories[epochId].entries.length;\n\n        if (entryLength == 0) {\n            return address(0);\n        }\n\n        // Staking all the Sylo would only be 94 bits, so multiplying this with\n        // a uint128 cannot overflow a uint256.\n        uint256 expectedVal = (directories[epochId].totalStake * uint256(point)) >> 128;\n\n        uint256 left;\n        uint256 right = entryLength - 1;\n\n        // perform a binary search through the directory\n        uint256 lower;\n        uint256 upper;\n        uint256 index;\n\n        while (left <= right) {\n            index = (left + right) >> 1;\n\n            lower = index == 0 ? 0 : directories[epochId].entries[index - 1].boundary;\n            upper = directories[epochId].entries[index].boundary;\n\n            if (expectedVal >= lower && expectedVal < upper) {\n                return directories[epochId].entries[index].stakee;\n            } else if (expectedVal < lower) {\n                right = index - 1;\n            } else {\n                // expectedVal >= upper\n                left = index + 1;\n            }\n        }\n    }\n\n    /**\n     * @notice Retrieve the total stake a Node has for the directory in the\n     * specified epoch.\n     * @param epochId The ID of the epoch.\n     * @param stakee The address of the Node.\n     * @return The amount of stake the Node has for the given directory in SOLO.\n     */\n    function getTotalStakeForStakee(\n        uint256 epochId,\n        address stakee\n    ) external view returns (uint256) {\n        return directories[epochId].stakes[stakee];\n    }\n\n    /**\n     * @notice Retrieve the total stake for a directory in the specified epoch, which\n     * will be the sum of the stakes for all Nodes participating in that epoch.\n     * @param epochId The ID of the epoch.\n     * @return The total amount of stake in SOLO.\n     */\n    function getTotalStake(uint256 epochId) external view returns (uint256) {\n        return directories[epochId].totalStake;\n    }\n\n    /**\n     * @notice Retrieve all entries for a directory in a specified epoch.\n     * @return An array of all the directory entries.\n     */\n    function getEntries(\n        uint256 epochId\n    ) external view returns (address[] memory, uint256[] memory) {\n        uint256 entryLength = directories[epochId].entries.length;\n\n        address[] memory stakees = new address[](entryLength);\n        uint256[] memory boundaries = new uint256[](entryLength);\n\n        DirectoryEntry memory entry;\n        DirectoryEntry[] memory entries = directories[epochId].entries;\n\n        for (uint256 i; i < entryLength; ++i) {\n            entry = entries[i];\n            stakees[i] = entry.stakee;\n            boundaries[i] = entry.boundary;\n        }\n        return (stakees, boundaries);\n    }\n}\n"
    },
    "contracts/staking/StakingManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\nimport \"../SyloToken.sol\";\nimport \"../libraries/SyloUtils.sol\";\nimport \"../SeekerPowerOracle.sol\";\nimport \"../epochs/EpochsManager.sol\";\nimport \"../payments/ticketing/RewardsManager.sol\";\nimport \"../interfaces/staking/IStakingManager.sol\";\n\n/**\n * @notice Manages stakes and delegated stakes for Nodes. Holding\n * staked Sylo is necessary for a Node to participate in the\n * Sylo Network. The stake is used in stake-weighted scan function,\n * and delegated stakers are rewarded on a pro-rata basis.\n */\ncontract StakingManager is IStakingManager, Initializable, Ownable2StepUpgradeable, ERC165 {\n    /** ERC 20 compatible token we are dealing with */\n    IERC20 public _token;\n\n    /**\n     * @notice Rewards Manager contract. Any changes to stake will automatically\n     * trigger a claim to any outstanding rewards.\n     */\n    RewardsManager public _rewardsManager;\n\n    EpochsManager public _epochsManager;\n\n    SeekerPowerOracle public _seekerPowerOracle;\n\n    /**\n     * @notice Tracks the managed stake for every Node.\n     */\n    mapping(address => Stake) public stakes;\n\n    /** @notice Tracks overall total stake held by this contract */\n    uint256 public totalManagedStake;\n\n    /**\n     * @notice Tracks funds that are in the process of being unlocked. This\n     * is indexed by a key that hashes both the address of the staked Node and\n     * the address of the staker.\n     */\n    mapping(bytes32 => Unlock) public unlockings;\n\n    /**\n     * @notice The number of blocks a user must wait after calling \"unlock\"\n     * before they can withdraw their stake\n     */\n    uint256 public unlockDuration;\n\n    /**\n     * @notice Minimum amount of stake that a Node needs to stake\n     * against itself in order to participate in the network. This is\n     * represented as a percentage of the Node's total stake, where\n     * the value is a ratio of 10000.\n     */\n    uint32 public minimumStakeProportion;\n\n    /**\n     * @notice The multiplier used in determining a Seeker's staking\n     * capacity based on its power level.\n     */\n    uint256 public seekerPowerMultiplier;\n\n    event UnlockDurationUpdated(uint256 unlockDuration);\n    event MinimumStakeProportionUpdated(uint256 minimumStakeProportion);\n    event SeekerPowerMultiplierUpdated(uint256 seekerPowerMultipler);\n\n    error NoStakeToUnlock();\n    error StakeNotYetUnlocked();\n    error CannotStakeZeroAmount();\n    error CannotUnlockZeroAmount();\n    error TokenCannotBeZeroAddress();\n    error StakeeCannotBeZeroAddress();\n    error UnlockDurationCannotBeZero();\n    error CannotCancelUnlockZeroAmount();\n    error CannotUnlockMoreThanStaked(uint256 stakeAmount, uint256 unlockAmount);\n    error StakeCapacityReached(uint256 maxCapacity, uint256 currentCapacity);\n    error SeekerPowerNotRegistered(uint256 seekerId);\n\n    function initialize(\n        IERC20 token,\n        RewardsManager rewardsManager,\n        EpochsManager epochsManager,\n        SeekerPowerOracle seekerPowerOracle,\n        uint256 _unlockDuration,\n        uint32 _minimumStakeProportion,\n        uint256 _seekerPowerMultiplier\n    ) external initializer {\n        if (address(token) == address(0)) {\n            revert TokenCannotBeZeroAddress();\n        }\n\n        SyloUtils.validateContractInterface(\n            \"RewardsManager\",\n            address(rewardsManager),\n            type(IRewardsManager).interfaceId\n        );\n\n        SyloUtils.validateContractInterface(\n            \"EpochsManager\",\n            address(epochsManager),\n            type(IEpochsManager).interfaceId\n        );\n\n        SyloUtils.validateContractInterface(\n            \"SeekerPowerOracle\",\n            address(seekerPowerOracle),\n            type(ISeekerPowerOracle).interfaceId\n        );\n\n        if (_unlockDuration == 0) {\n            revert UnlockDurationCannotBeZero();\n        }\n\n        Ownable2StepUpgradeable.__Ownable2Step_init();\n\n        _token = token;\n        _rewardsManager = rewardsManager;\n        _epochsManager = epochsManager;\n        _seekerPowerOracle = seekerPowerOracle;\n        unlockDuration = _unlockDuration;\n        minimumStakeProportion = _minimumStakeProportion;\n        seekerPowerMultiplier = _seekerPowerMultiplier;\n    }\n\n    /**\n     * @notice Returns true if the contract implements the interface defined by\n     * `interfaceId` from ERC165.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IStakingManager).interfaceId;\n    }\n\n    /**\n     * @notice Sets the unlock duration for stakes. Only callable by\n     * the owner.\n     * @param _unlockDuration The unlock duration in number of blocks.\n     */\n    function setUnlockDuration(uint256 _unlockDuration) external onlyOwner {\n        if (_unlockDuration == 0) {\n            revert UnlockDurationCannotBeZero();\n        }\n\n        unlockDuration = _unlockDuration;\n        emit UnlockDurationUpdated(_unlockDuration);\n    }\n\n    function setSeekerPowerMultiplier(uint256 _seekerPowerMultiplier) external onlyOwner {\n        seekerPowerMultiplier = _seekerPowerMultiplier;\n        emit SeekerPowerMultiplierUpdated(seekerPowerMultiplier);\n    }\n\n    /**\n     * @notice Sets the minimum stake proportion for Nodes. Only callable by\n     * the owner.\n     * @param _minimumStakeProportion The minimum stake proportion in SOLO.\n     */\n    function setMinimumStakeProportion(uint32 _minimumStakeProportion) external onlyOwner {\n        minimumStakeProportion = _minimumStakeProportion;\n        emit MinimumStakeProportionUpdated(_minimumStakeProportion);\n    }\n\n    /**\n     * @notice Called by Nodes and delegated stakers to add stake.\n     * This function will fail under the following conditions:\n     *   - If the Node address is invalid\n     *   - If the specified stake value is zero\n     *   - If the additional stake causes the Node to fail to meet the\n     *     minimum stake proportion requirement.\n     * @param amount The amount of stake to add in SOLO.\n     * @param stakee The address of the staked Node.\n     */\n    function addStake(uint256 amount, address stakee) external {\n        if (stakee == address(0)) {\n            revert StakeeCannotBeZeroAddress();\n        }\n        if (amount == 0) {\n            revert CannotStakeZeroAmount();\n        }\n\n        _addStake(amount, stakee);\n        SafeERC20.safeTransferFrom(_token, msg.sender, address(this), amount);\n    }\n\n    function _addStake(uint256 amount, address stakee) internal {\n        // automatically move any pending rewards generated by their existing stake\n        _rewardsManager.updatePendingRewards(stakee, msg.sender);\n\n        uint256 currentEpochId = _epochsManager.currentIteration();\n\n        Stake storage stake = stakes[stakee];\n\n        uint256 currentStake = getCurrentStakerAmount(stakee, msg.sender);\n\n        stake.stakeEntries[msg.sender] = StakeEntry(\n            currentStake + amount,\n            block.number,\n            currentEpochId\n        );\n\n        stake.totalManagedStake = stake.totalManagedStake + amount;\n        totalManagedStake = totalManagedStake + amount;\n    }\n\n    /**\n     * @notice Call this function to begin the unlocking process. Calling this\n     * will trigger an automatic claim of any outstanding staking rewards. Any\n     * stake that was already in the unlocking phase will have the specified\n     * amount added to it, and its duration refreshed. This function will fail\n     * under the following conditions:\n     *   - If no stake exists for the caller\n     *   - If the unlock amount is zero\n     *   - If the unlock amount is more than what is staked\n     * Note: If calling as a Node, this function will *not* revert if it causes\n     * the Node to fail to meet the minimum stake proportion. However it will still\n     * prevent the Node from participating in the network until the minimum is met\n     * again.\n     * @param amount The amount of stake to unlock in SOLO.\n     * @param stakee The address of the staked Node.\n     */\n    function unlockStake(uint256 amount, address stakee) external returns (uint256) {\n        if (stakee == address(0)) {\n            revert StakeeCannotBeZeroAddress();\n        }\n        if (amount == 0) {\n            revert CannotUnlockZeroAmount();\n        }\n\n        uint256 currentStake = getCurrentStakerAmount(stakee, msg.sender);\n\n        if (currentStake == 0) {\n            revert NoStakeToUnlock();\n        }\n        if (currentStake < amount) {\n            revert CannotUnlockMoreThanStaked(currentStake, amount);\n        }\n\n        // automatically move any pending rewards generated by their existing stake\n        _rewardsManager.updatePendingRewards(stakee, msg.sender);\n\n        uint256 currentEpochId = _epochsManager.currentIteration();\n\n        Stake storage stake = stakes[stakee];\n\n        stake.stakeEntries[msg.sender] = StakeEntry(\n            currentStake - amount,\n            block.number,\n            currentEpochId\n        );\n\n        stake.totalManagedStake = stake.totalManagedStake - amount;\n        totalManagedStake = totalManagedStake - amount;\n\n        bytes32 key = getKey(stakee, msg.sender);\n\n        // Keep track of when the stake can be withdrawn\n        Unlock storage unlock = unlockings[key];\n\n        uint256 unlockAt = block.number + unlockDuration;\n        if (unlock.unlockAt < unlockAt) {\n            unlock.unlockAt = unlockAt;\n        }\n\n        unlock.amount = unlock.amount + amount;\n\n        return unlockAt;\n    }\n\n    /**\n     * @notice Call this function to withdraw stake that has finished unlocking.\n     * This will fail if the stake has not yet unlocked.\n     * @param stakee The address of the staked Node.\n     */\n    function withdrawStake(address stakee) external {\n        if (stakee == address(0)) {\n            revert StakeeCannotBeZeroAddress();\n        }\n\n        bytes32 key = getKey(stakee, msg.sender);\n\n        Unlock storage unlock = unlockings[key];\n\n        if (unlock.unlockAt >= block.number) {\n            revert StakeNotYetUnlocked();\n        }\n\n        uint256 amount = unlock.amount;\n\n        delete unlockings[key];\n\n        SafeERC20.safeTransfer(_token, msg.sender, amount);\n    }\n\n    /**\n     * @notice Call this function to cancel any stake that is in the process\n     * of unlocking. As this essentially adds back stake to the Node, this\n     * will trigger an automatic claim of any outstanding staking rewards.\n     * If the specified amount to cancel is greater than the stake that is\n     * currently being unlocked, it will cancel the maximum stake possible.\n     * @param amount The amount of unlocking stake to cancel in SOLO.\n     * @param stakee The address of the staked Node.\n     */\n    function cancelUnlocking(uint256 amount, address stakee) external {\n        if (stakee == address(0)) {\n            revert StakeeCannotBeZeroAddress();\n        }\n        if (amount == 0) {\n            revert CannotCancelUnlockZeroAmount();\n        }\n\n        bytes32 key = getKey(stakee, msg.sender);\n\n        Unlock storage unlock = unlockings[key];\n\n        if (amount >= unlock.amount) {\n            amount = unlock.amount;\n            delete unlockings[key];\n        } else {\n            unlock.amount = unlock.amount - amount;\n        }\n\n        _addStake(amount, stakee);\n    }\n\n    /**\n     * @notice This function determines the staking capacity of\n     * a Seeker based on its power level. The method will revert if\n     * the Seeker's power level has not been registered with the oracle.\n     *\n     * Currently the algorithm is as follows:\n     *    staking_capacity = seeker_power * seeker_power_multiplier;\n     */\n    function calculateCapacityFromSeekerPower(uint256 seekerId) external view returns (uint256) {\n        uint256 seekerPower = _seekerPowerOracle.getSeekerPower(seekerId);\n        if (seekerPower == 0) {\n            revert SeekerPowerNotRegistered(seekerId);\n        }\n\n        // If the Seeker Power is already\n        // at the maximum sylo, then we just return the max sylo value directly.\n        if (seekerPower >= SyloUtils.MAX_SYLO) {\n            return SyloUtils.MAX_SYLO;\n        }\n\n        uint256 capacity = seekerPower * seekerPowerMultiplier;\n\n        return capacity > SyloUtils.MAX_SYLO ? SyloUtils.MAX_SYLO : capacity;\n    }\n\n    /**\n     * @notice This function can be used to a determine a Node's staking capacity,\n     * based on the minimum stake proportion constant.\n     * @param stakee The address of the staked Node.\n     */\n    function calculateCapacityFromMinStakingProportion(address stakee) public view returns (uint256) {\n        if (stakee == address(0)) {\n            revert StakeeCannotBeZeroAddress();\n        }\n\n        Stake storage stake = stakes[stakee];\n\n        uint256 currentlyOwnedStake = stake.stakeEntries[stakee].amount;\n        return (currentlyOwnedStake * SyloUtils.PERCENTAGE_DENOMINATOR) /\n            minimumStakeProportion;\n    }\n\n    /**\n     * @notice This function should be called by clients to determine how much\n     * additional delegated stake can be allocated to a Node via an addStake or\n     * cancelUnlocking call. This is useful to avoid a revert due to\n     * the minimum stake proportion requirement not being met from the additional stake.\n     * @param stakee The address of the staked Node.\n     */\n    function calculateMaxAdditionalDelegatedStake(address stakee) external view returns (uint256) {\n        uint256 totalMaxStake = calculateCapacityFromMinStakingProportion(stakee);\n\n        Stake storage stake = stakes[stakee];\n\n        if (totalMaxStake < stake.totalManagedStake) {\n            revert StakeCapacityReached(totalMaxStake, stake.totalManagedStake);\n        }\n\n        return totalMaxStake - stake.totalManagedStake;\n    }\n\n    /**\n     * @notice Retrieve the key used to index a stake entry. The key is a hash\n     * which takes both address of the Node and the staker as input.\n     * @param stakee The address of the staked Node.\n     * @param staker The address of the staker.\n     * @return A byte-array representing the key.\n     */\n    function getKey(address stakee, address staker) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(stakee, staker));\n    }\n\n    /**\n     * @notice Retrieve the total stake being managed by this contract.\n     * @return The total amount of managed stake in SOLO.\n     */\n    function getTotalManagedStake() external view returns (uint256) {\n        return totalManagedStake;\n    }\n\n    /**\n     * @notice Retrieve a stake entry.\n     * @param stakee The address of the staked Node.\n     * @param staker The address of the staker.\n     * @return The stake entry.\n     */\n    function getStakeEntry(\n        address stakee,\n        address staker\n    ) external view returns (StakeEntry memory) {\n        return stakes[stakee].stakeEntries[staker];\n    }\n\n    /**\n     * @notice Retrieve the total amount of SOLO staked against a Node.\n     * @param stakee The address of the staked Node.\n     * @return The amount of staked SOLO.\n     */\n    function getStakeeTotalManagedStake(address stakee) external view returns (uint256) {\n        return stakes[stakee].totalManagedStake;\n    }\n\n    /**\n     * @notice Check if a Node is meeting the minimum stake proportion requirement.\n     * @param stakee The address of the staked Node.\n     * @return True if the Node is meeting minimum stake proportion requirement.\n     */\n    function checkMinimumStakeProportion(address stakee) public view returns (bool) {\n        if (stakee == address(0)) {\n            revert StakeeCannotBeZeroAddress();\n        }\n\n        Stake storage stake = stakes[stakee];\n\n        uint256 currentlyOwnedStake = stake.stakeEntries[stakee].amount;\n        uint32 ownedStakeProportion = SyloUtils.asPerc(\n            SafeCast.toUint128(currentlyOwnedStake),\n            stake.totalManagedStake\n        );\n\n        return ownedStakeProportion >= minimumStakeProportion;\n    }\n\n    /**\n     * @notice Retrieve the current amount of SOLO staked against a Node by\n     * a specified staker.\n     * @param stakee The address of the staked Node.\n     * @param staker The address of the staker.\n     * @return The amount of staked SOLO.\n     */\n    function getCurrentStakerAmount(address stakee, address staker) public view returns (uint256) {\n        return stakes[stakee].stakeEntries[staker].amount;\n    }\n}\n"
    },
    "contracts/SyloToken.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract SyloToken is ERC20 {\n    constructor() ERC20(\"Sylo\", \"SYLO\") {\n        _mint(msg.sender, 10_000_000_000 ether);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}